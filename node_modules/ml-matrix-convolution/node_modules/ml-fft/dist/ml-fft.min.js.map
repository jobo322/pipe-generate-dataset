{"version":3,"sources":["webpack:///ml-fft/webpack/universalModuleDefinition","webpack:///ml-fft/ml-fft.min.js","webpack:///ml-fft/webpack/bootstrap 430bceb9f43a96cd6102","webpack:///ml-fft/./src/index.js","webpack:///ml-fft/./src/FFTUtils.js","webpack:///ml-fft/./src/fftlib.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FFTUtils","FFT","DEBUG","ifft2DArray","ft","ftRows","ftCols","tempTransform","Array","nRows","nCols","init","tmpCols","re","im","iCol","iRow","bt","finalTransform","tmpRows","scale","indexB","fft2DArray","data","index","iRow0","iRow1","iRow2","iRow3","row1","row2","slice","fft1d","reconstructTwoRealFFT","k","fourierTransform","realTransform1","realTransform2","length","rm","rp","ip","j","i","convolute2DI","ftSignal","ftFilter","convolute","kernel","ftSpectrum","dim","ftFilterData","shift","ir","ic","version","release","date","toString","_n","_bitrev","_cstb","core","n","Error","_initArray","_makeBitReversalTable","_makeCosSinTable","fft","ifft1d","bt1d","fft2d","tre","tim","y","x1","x2","x","y1","y2","ifft2d","inv","d","h","ik","tmp","wr","wi","xr","xi","n4","l","Uint32Array","Float64Array","_paddingZero","n2","n8","n2p4","t","Math","sin","PI","dc","ds","sqrt","s","apis","ifft"],"mappings":"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","file":"ml-fft.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlFft\"] = factory();\n\telse\n\t\troot[\"mlFft\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlFft\"] = factory();\n\telse\n\t\troot[\"mlFft\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.FFTUtils = __webpack_require__(1);\n\texports.FFT = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar FFT = __webpack_require__(2);\n\t\n\tvar FFTUtils= {\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * Calculates the inverse of a 2D Fourier transform\n\t     *\n\t     * @param ft\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    ifft2DArray : function(ft, ftRows, ftCols){\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        var nRows = ftRows / 2;\n\t        var nCols = (ftCols - 1) * 2;\n\t        // reverse transform columns\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = 0; iCol < ftCols; iCol++) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        // reverse row transform\n\t        var finalTransform = new Array(nRows * nCols);\n\t        FFT.init(nCols);\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var scale = nCols * nRows;\n\t        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n\t            tmpRows.re[0] = tempTransform[iRow * ftCols];\n\t            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n\t            for (var iCol = 1; iCol < ftCols; iCol++) {\n\t                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n\t                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpRows.re, tmpRows.im);\n\t\n\t            var indexB = (iRow / 2) * nCols;\n\t            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n\t                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n\t            }\n\t        }\n\t        return finalTransform;\n\t    },\n\t    /**\n\t     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n\t     * assumed that both nRows and nCols are a power of two\n\t     *\n\t     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n\t     * even rows contain the real part and the odd rows the imaginary part of the\n\t     * transform\n\t     * @param data\n\t     * @param nRows\n\t     * @param nCols\n\t     * @return\n\t     */\n\t    fft2DArray:function(data, nRows, nCols) {\n\t        var ftCols = (nCols / 2 + 1);\n\t        var ftRows = nRows * 2;\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nCols);\n\t        // transform rows\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var index, iRow0, iRow1, iRow2, iRow3;\n\t        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n\t            index = (iRow * 2) * nCols;\n\t            tmpRows.re = data.slice(index, index + nCols);\n\t\n\t            index = (iRow * 2 + 1) * nCols;\n\t            tmpRows.im = data.slice(index, index + nCols);\n\t\n\t            FFT.fft1d(tmpRows.re, tmpRows.im);\n\t\n\t            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n\t            //Now lets put back the result into the output array\n\t            iRow0 = (iRow * 4) * ftCols;\n\t            iRow1 = (iRow * 4 + 1) * ftCols;\n\t            iRow2 = (iRow * 4 + 2) * ftCols;\n\t            iRow3 = (iRow * 4 + 3) * ftCols;\n\t            for (var k = ftCols - 1; k >= 0; k--) {\n\t                tempTransform[iRow0 + k] = row1.re[k];\n\t                tempTransform[iRow1 + k] = row1.im[k];\n\t                tempTransform[iRow2 + k] = row2.re[k];\n\t                tempTransform[iRow3 + k] = row2.im[k];\n\t            }\n\t        }\n\t\n\t        //console.log(tempTransform);\n\t        row1 = null;\n\t        row2 = null;\n\t        // transform columns\n\t        var finalTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            FFT.fft1d(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        //console.log(finalTransform);\n\t        return finalTransform;\n\t\n\t    },\n\t    /**\n\t     *\n\t     * @param fourierTransform\n\t     * @param realTransform1\n\t     * @param realTransform2\n\t     *\n\t     * Reconstructs the individual Fourier transforms of two simultaneously\n\t     * transformed series. Based on the Symmetry relationships (the asterisk\n\t     * denotes the complex conjugate)\n\t     *\n\t     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n\t     *\n\t     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n\t     *\n\t     */\n\t    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n\t        var length = fourierTransform.re.length;\n\t\n\t        // the components n=0 are trivial\n\t        realTransform1.re[0] = fourierTransform.re[0];\n\t        realTransform1.im[0] = 0.0;\n\t        realTransform2.re[0] = fourierTransform.im[0];\n\t        realTransform2.im[0] = 0.0;\n\t        var rm, rp, im, ip, j;\n\t        for (var i = length / 2; i > 0; i--) {\n\t            j = length - i;\n\t            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n\t            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n\t            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n\t            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n\t            realTransform1.re[i] = rp;\n\t            realTransform1.im[i] = im;\n\t            realTransform1.re[j] = rp;\n\t            realTransform1.im[j] = -im;\n\t            realTransform2.re[i] = ip;\n\t            realTransform2.im[i] = -rm;\n\t            realTransform2.re[j] = ip;\n\t            realTransform2.im[j] = rm;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * In place version of convolute 2D\n\t     *\n\t     * @param ftSignal\n\t     * @param ftFilter\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n\t        var re, im;\n\t        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n\t            for (var iCol = 0; iCol < ftCols; iCol++) {\n\t                //\n\t                re = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol]\n\t                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n\t                im = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n\t                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                * ftFilter[(iRow * 2) * ftCols + iCol];\n\t                //\n\t                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n\t                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     *\n\t     * @param data\n\t     * @param kernel\n\t     * @param nRows\n\t     * @param nCols\n\t     * @returns {*}\n\t     */\n\t    convolute:function(data, kernel, nRows, nCols){\n\t        var ftSpectrum = new Array(nCols * nRows);\n\t        for (var i = 0; i<nRows * nCols; i++){\n\t            ftSpectrum[i] = data[i];\n\t        }\n\t\n\t        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\t\n\t        var dim = kernel.length;\n\t        var ftFilterData = new Array(nCols * nRows);\n\t        for(var i=0;i<nCols * nRows;i++){\n\t            ftFilterData[i]=0;\n\t        }\n\t\n\t        var iRow, iCol;\n\t        var shift = (dim - 1) / 2;\n\t        //console.log(dim);\n\t        for (var ir = 0; ir < dim; ir++) {\n\t            iRow = (ir - shift + nRows) % nRows;\n\t            for (var ic = 0; ic < dim; ic++) {\n\t                iCol = (ic - shift + nCols) % nCols;\n\t                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n\t            }\n\t        }\n\t\n\t        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\t\n\t        var ftRows = nRows * 2;\n\t        var ftCols = nCols / 2 + 1;\n\t        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\t\n\t        return  this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n\t    }\n\t}\n\t\n\tmodule.exports = FFTUtils;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Fast Fourier Transform module\n\t * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n\t */\n\tvar FFT = (function(){\n\t  var FFT;  \n\t  \n\t  if(true) {\n\t    FFT = exports;   // for CommonJS\n\t  } else {\n\t    FFT = {};\n\t  }\n\t  \n\t  var version = {\n\t    release: '0.3.0',\n\t    date: '2013-03'\n\t  };\n\t  FFT.toString = function() {\n\t    return \"version \" + version.release + \", released \" + version.date;\n\t  };\n\t\n\t  // core operations\n\t  var _n = 0,          // order\n\t      _bitrev = null,  // bit reversal table\n\t      _cstb = null;    // sin/cos table\n\t\n\t  var core = {\n\t    init : function(n) {\n\t      if(n !== 0 && (n & (n - 1)) === 0) {\n\t        _n = n;\n\t        core._initArray();\n\t        core._makeBitReversalTable();\n\t        core._makeCosSinTable();\n\t      } else {\n\t        throw new Error(\"init: radix-2 required\");\n\t      }\n\t    },\n\t    // 1D-FFT\n\t    fft1d : function(re, im) {\n\t      core.fft(re, im, 1);\n\t    },\n\t    // 1D-IFFT\n\t    ifft1d : function(re, im) {\n\t      var n = 1/_n;\n\t      core.fft(re, im, -1);\n\t      for(var i=0; i<_n; i++) {\n\t        re[i] *= n;\n\t        im[i] *= n;\n\t      }\n\t    },\n\t     // 1D-IFFT\n\t    bt1d : function(re, im) {\n\t      core.fft(re, im, -1);\n\t    },\n\t    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n\t    fft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // 2D-IFFT\n\t    ifft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // core operation of FFT\n\t    fft : function(re, im, inv) {\n\t      var d, h, ik, m, tmp, wr, wi, xr, xi,\n\t          n4 = _n >> 2;\n\t      // bit reversal\n\t      for(var l=0; l<_n; l++) {\n\t        m = _bitrev[l];\n\t        if(l < m) {\n\t          tmp = re[l];\n\t          re[l] = re[m];\n\t          re[m] = tmp;\n\t          tmp = im[l];\n\t          im[l] = im[m];\n\t          im[m] = tmp;\n\t        }\n\t      }\n\t      // butterfly operation\n\t      for(var k=1; k<_n; k<<=1) {\n\t        h = 0;\n\t        d = _n/(k << 1);\n\t        for(var j=0; j<k; j++) {\n\t          wr = _cstb[h + n4];\n\t          wi = inv*_cstb[h];\n\t          for(var i=j; i<_n; i+=(k<<1)) {\n\t            ik = i + k;\n\t            xr = wr*re[ik] + wi*im[ik];\n\t            xi = wr*im[ik] - wi*re[ik];\n\t            re[ik] = re[i] - xr;\n\t            re[i] += xr;\n\t            im[ik] = im[i] - xi;\n\t            im[i] += xi;\n\t          }\n\t          h += d;\n\t        }\n\t      }\n\t    },\n\t    // initialize the array (supports TypedArray)\n\t    _initArray : function() {\n\t      if(typeof Uint32Array !== 'undefined') {\n\t        _bitrev = new Uint32Array(_n);\n\t      } else {\n\t        _bitrev = [];\n\t      }\n\t      if(typeof Float64Array !== 'undefined') {\n\t        _cstb = new Float64Array(_n*1.25);\n\t      } else {\n\t        _cstb = [];\n\t      }\n\t    },\n\t    // zero padding\n\t    _paddingZero : function() {\n\t      // TODO\n\t    },\n\t    // makes bit reversal table\n\t    _makeBitReversalTable : function() {\n\t      var i = 0,\n\t          j = 0,\n\t          k = 0;\n\t      _bitrev[0] = 0;\n\t      while(++i < _n) {\n\t        k = _n >> 1;\n\t        while(k <= j) {\n\t          j -= k;\n\t          k >>= 1;\n\t        }\n\t        j += k;\n\t        _bitrev[i] = j;\n\t      }\n\t    },\n\t    // makes trigonometiric function table\n\t    _makeCosSinTable : function() {\n\t      var n2 = _n >> 1,\n\t          n4 = _n >> 2,\n\t          n8 = _n >> 3,\n\t          n2p4 = n2 + n4,\n\t          t = Math.sin(Math.PI/_n),\n\t          dc = 2*t*t,\n\t          ds = Math.sqrt(dc*(2 - dc)),\n\t          c = _cstb[n4] = 1,\n\t          s = _cstb[0] = 0;\n\t      t = 2*dc;\n\t      for(var i=1; i<n8; i++) {\n\t        c -= dc;\n\t        dc += t*c;\n\t        s += ds;\n\t        ds -= t*s;\n\t        _cstb[i] = s;\n\t        _cstb[n4 - i] = c;\n\t      }\n\t      if(n8 !== 0) {\n\t        _cstb[n8] = Math.sqrt(0.5);\n\t      }\n\t      for(var j=0; j<n4; j++) {\n\t        _cstb[n2 - j]  = _cstb[j];\n\t      }\n\t      for(var k=0; k<n2p4; k++) {\n\t        _cstb[k + n2] = -_cstb[k];\n\t      }\n\t    }\n\t  };\n\t  // aliases (public APIs)\n\t  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n\t  for(var i=0; i<apis.length; i++) {\n\t    FFT[apis[i]] = core[apis[i]];\n\t  }\n\t  FFT.bt = core.bt1d;\n\t  FFT.fft = core.fft1d;\n\t  FFT.ifft = core.ifft1d;\n\t  \n\t  return FFT;\n\t}).call(this);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ml-fft.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 430bceb9f43a96cd6102\n **/","'use strict';\n\nexports.FFTUtils = require(\"./FFTUtils\");\nexports.FFT = require('./fftlib');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","var FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols) {\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol]\n                - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    },\n    /**\n     *\n     * @param data\n     * @param kernel\n     * @param nRows\n     * @param nCols\n     * @returns {*}\n     */\n    convolute:function(data, kernel, nRows, nCols){\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = 0; i<nRows * nCols; i++){\n            ftSpectrum[i] = data[i];\n        }\n\n        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\n        var dim = kernel.length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i=0;i<nCols * nRows;i++){\n            ftFilterData[i]=0;\n        }\n\n        var iRow, iCol;\n        var shift = (dim - 1) / 2;\n        //console.log(dim);\n        for (var ir = 0; ir < dim; ir++) {\n            iRow = (ir - shift + nRows) % nRows;\n            for (var ic = 0; ic < dim; ic++) {\n                iCol = (ic - shift + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n            }\n        }\n\n        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return  this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    }\n}\n\nmodule.exports = FFTUtils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/FFTUtils.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Fast Fourier Transform module\n * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n */\nvar FFT = (function(){\n  var FFT;  \n  \n  if(typeof exports !== 'undefined') {\n    FFT = exports;   // for CommonJS\n  } else {\n    FFT = {};\n  }\n  \n  var version = {\n    release: '0.3.0',\n    date: '2013-03'\n  };\n  FFT.toString = function() {\n    return \"version \" + version.release + \", released \" + version.date;\n  };\n\n  // core operations\n  var _n = 0,          // order\n      _bitrev = null,  // bit reversal table\n      _cstb = null;    // sin/cos table\n\n  var core = {\n    init : function(n) {\n      if(n !== 0 && (n & (n - 1)) === 0) {\n        _n = n;\n        core._initArray();\n        core._makeBitReversalTable();\n        core._makeCosSinTable();\n      } else {\n        throw new Error(\"init: radix-2 required\");\n      }\n    },\n    // 1D-FFT\n    fft1d : function(re, im) {\n      core.fft(re, im, 1);\n    },\n    // 1D-IFFT\n    ifft1d : function(re, im) {\n      var n = 1/_n;\n      core.fft(re, im, -1);\n      for(var i=0; i<_n; i++) {\n        re[i] *= n;\n        im[i] *= n;\n      }\n    },\n     // 1D-IFFT\n    bt1d : function(re, im) {\n      core.fft(re, im, -1);\n    },\n    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n    fft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.fft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.fft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // 2D-IFFT\n    ifft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.ifft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.ifft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // core operation of FFT\n    fft : function(re, im, inv) {\n      var d, h, ik, m, tmp, wr, wi, xr, xi,\n          n4 = _n >> 2;\n      // bit reversal\n      for(var l=0; l<_n; l++) {\n        m = _bitrev[l];\n        if(l < m) {\n          tmp = re[l];\n          re[l] = re[m];\n          re[m] = tmp;\n          tmp = im[l];\n          im[l] = im[m];\n          im[m] = tmp;\n        }\n      }\n      // butterfly operation\n      for(var k=1; k<_n; k<<=1) {\n        h = 0;\n        d = _n/(k << 1);\n        for(var j=0; j<k; j++) {\n          wr = _cstb[h + n4];\n          wi = inv*_cstb[h];\n          for(var i=j; i<_n; i+=(k<<1)) {\n            ik = i + k;\n            xr = wr*re[ik] + wi*im[ik];\n            xi = wr*im[ik] - wi*re[ik];\n            re[ik] = re[i] - xr;\n            re[i] += xr;\n            im[ik] = im[i] - xi;\n            im[i] += xi;\n          }\n          h += d;\n        }\n      }\n    },\n    // initialize the array (supports TypedArray)\n    _initArray : function() {\n      if(typeof Uint32Array !== 'undefined') {\n        _bitrev = new Uint32Array(_n);\n      } else {\n        _bitrev = [];\n      }\n      if(typeof Float64Array !== 'undefined') {\n        _cstb = new Float64Array(_n*1.25);\n      } else {\n        _cstb = [];\n      }\n    },\n    // zero padding\n    _paddingZero : function() {\n      // TODO\n    },\n    // makes bit reversal table\n    _makeBitReversalTable : function() {\n      var i = 0,\n          j = 0,\n          k = 0;\n      _bitrev[0] = 0;\n      while(++i < _n) {\n        k = _n >> 1;\n        while(k <= j) {\n          j -= k;\n          k >>= 1;\n        }\n        j += k;\n        _bitrev[i] = j;\n      }\n    },\n    // makes trigonometiric function table\n    _makeCosSinTable : function() {\n      var n2 = _n >> 1,\n          n4 = _n >> 2,\n          n8 = _n >> 3,\n          n2p4 = n2 + n4,\n          t = Math.sin(Math.PI/_n),\n          dc = 2*t*t,\n          ds = Math.sqrt(dc*(2 - dc)),\n          c = _cstb[n4] = 1,\n          s = _cstb[0] = 0;\n      t = 2*dc;\n      for(var i=1; i<n8; i++) {\n        c -= dc;\n        dc += t*c;\n        s += ds;\n        ds -= t*s;\n        _cstb[i] = s;\n        _cstb[n4 - i] = c;\n      }\n      if(n8 !== 0) {\n        _cstb[n8] = Math.sqrt(0.5);\n      }\n      for(var j=0; j<n4; j++) {\n        _cstb[n2 - j]  = _cstb[j];\n      }\n      for(var k=0; k<n2p4; k++) {\n        _cstb[k + n2] = -_cstb[k];\n      }\n    }\n  };\n  // aliases (public APIs)\n  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n  for(var i=0; i<apis.length; i++) {\n    FFT[apis[i]] = core[apis[i]];\n  }\n  FFT.bt = core.bt1d;\n  FFT.fft = core.fft1d;\n  FFT.ifft = core.ifft1d;\n  \n  return FFT;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/fftlib.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}