'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeImpurities;

var _impurities = require('./impurities');

var _impurities2 = _interopRequireDefault(_impurities);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const toCheck = ['solvent_residual_peak', 'H2O', 'TMS'];

function checkImpurity(peakList, impurity, options) {
    var j, tolerance, diference;
    var i = impurity.length;
    while (i--) {
        j = peakList.length;
        while (j--) {
            if (!peakList[j].asymmetric) {
                tolerance = options.error + peakList[j].width;
                diference = Math.abs(impurity[i].shift - peakList[j].x);
                if (diference < tolerance) {
                    // && (impurity[i].multiplicity === '' || (impurity[i].multiplicity.indexOf(peakList[j].multiplicity)) { // some impurities has multiplicities like 'bs' but at presents it is unsupported
                    peakList.splice(j, 1);
                }
            }
        }
    }
}

function removeImpurities(peakList, options = {}) {
    var {
        solvent = '',
        error = 0.025
    } = options;
    solvent = solvent.toLowerCase();
    if (solvent === '(cd3)2so') solvent = 'dmso';
    if (solvent === 'meod') solvent = 'cd3od';
    var solventImpurities = _impurities2.default[solvent];
    if (solventImpurities) {
        for (let impurity of toCheck) {
            let impurityShifts = solventImpurities[impurity.toLowerCase()];
            checkImpurity(peakList, impurityShifts, { error: error });
        }
    }
    return peakList;
}