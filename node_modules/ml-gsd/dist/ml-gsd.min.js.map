{"version":3,"sources":["webpack:///ml-gsd/webpack/universalModuleDefinition","webpack:///ml-gsd/webpack/bootstrap 291484932c94a4c31894","webpack:///ml-gsd/./src/index.js","webpack:///ml-gsd/./src/optimize.js","webpack:///ml-gsd/./~/ml-optimize-lorentzian/src/index.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/index.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/LM.js","webpack:///ml-gsd/./~/ml-matrix/src/index.js","webpack:///ml-gsd/./~/ml-matrix/src/matrix.js","webpack:///ml-gsd/./~/ml-matrix/src/decompositions.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/svd.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/util.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/evd.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/lu.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/qr.js","webpack:///ml-gsd/./~/ml-matrix/src/dc/cholesky.js","webpack:///ml-gsd/./~/ml-curve-fitting/src/algebra.js","webpack:///ml-gsd/./src/gsd.js","webpack:///ml-gsd/./~/extend/index.js","webpack:///ml-gsd/./~/ml-savitzky-golay-generalized/src/index.js","webpack:///ml-gsd/./~/ml-savitzky-golay-generalized/~/ml-stat/index.js","webpack:///ml-gsd/./~/ml-savitzky-golay-generalized/~/ml-stat/array.js","webpack:///ml-gsd/./~/ml-savitzky-golay-generalized/~/ml-stat/matrix.js"],"names":[],"mappings":"AAAA,cACA,2BACA,uCACA,sCACA,cACA,GACA,qCAEA,UACA,GAAC,mBACD,kBCTA,cAMA,MACA,eAGA,mBACA,CACA,cACA,EAIA,kDAGA,KAGA,YACA,OAIA,IAzBA,iBA4BA,MAGA,MAGA,yBCtCA,CAEA,8BACA,uCCAA,CAEA,kCAGA,SACA,OACA,KACA,wBACA,KACA,sBAGA,2BACA,UACA,EACA,SACA,YACA,wBACA,YACA,aACA,OAGA,GAEA,yBAGA,EAKA,iBACA,KACA,EAEA,gBAgEA,IACA,MACA,OACA,mBACA,SAEA,QAAe,MAAqB,OAEpC,yCAEA,aAEA,aACA,uBACA,oBAEA,gBACA,uBACA,oBAEA,gCAGA,aAAyB,eAEzB,SACA,qBAGA,oBAAiB,eAEjB,eAA+B,EAAQ,KAEvC,6CACA,wCACA,OAAuB,iBAAgC,OACvD,iCAEA,iCACA,qCACA,qCAEA,iCACA,qCACA,qCAGA,uCAEA,gBACA,EAEA,OACA,EAMA,SA7JA,cAsQkB,iCAnOlB,SACA,YACA,GACA,OACA,EACA,mBACA,iBACA,QAAe,MAAmB,WAClC,aACA,SAKA,oFAEA,iBACA,eACA,mCAEA,MACA,WACA,6CAEA,GACA,kDAIA,MAA2B,OAAqB,OAChD,YAAiC,8CAEjC,GAGA,gBACA,iBACA,0BAGA,iBACA,YACA,mCAGA,MACA,OACA,0DAEA,GACA,+DAIA,YAA6B,qCAC7B,GAGA,CACA,OACA,EAEA,8BA6DA,SACA,MAEA,eACA,qBAAqC,EAAQ,KAC7C,SACA,2BAIA,YAAqB,SAErB,yBACA,OACA,IAEA,gBAAmB,MAAuB,OAE1C,iCACA,sBACA,WACA,WACA,IAEA,UACA,GACS,QACT,QACA,kCACA,GAAqB,kDACrB,cAA+B,kCAE/B,SAEA,uBACA,UACA,GAEA,mBACA,OACA,UACA,IACA,IACA,CAGA,4BACA,cACA,CAEA,GAEA,CAoDA,mBC7QA,CAEA,8BAaA,8BACA,yBAEA,WAAY,IACZ,iCACA,eACA,MAAgB,IAChB,6CAGA,SACA,GA6BA,kBACA,kCACA,OACA,sBACA,qBAAgB,IAChB,8DAEA,UACA,EASA,kBACA,uBACA,MACA,sBACA,qBAAgB,IAChB,kEAEA,SACA,EAOA,kBACA,GACA,8BAEA,gBACA,kBAGA,cACA,OACA,OACA,OAEA,0BAEA,uBAGA,gFACA,wCACA,gCACA,4CACA,gCAEA,kDAGA,gBACA,yBAEA,GAOA,kBACA,GACA,8BAEA,gBACA,kBAGA,cACA,OACA,OAEA,OAIA,0BAEA,uBAGA,gFACA,wCAEA,wEACA,+BACA,4CACA,gCAIA,kDACA,gBACA,yBACA,GAKA,gBAqNA,SACA,SACA,cACA,MAEA,UAEA,aAIA,kBACA,YACA,QACA,OACA,GACA,8BAAoB,KACpB,WACA,UACA,QACA,QAKA,YACA,8BAAwB,KACxB,cACA,aACA,WACA,WAOA,GACA,KAEA,QAIA,cACA,YACA,MAAmB,IAAc,GACjC,cACA,aACA,QACA,QAGA,GACA,OAAe,IAAc,GAC7B,UAEA,KACA,WAA4B,EAAO,KACnC,SACA,eACA,cAIA,UACA,2DACA,GACA,IAMA,SA/bA,cACA,YAUA,sCAqbA,YACA,qCAvMA,SAEA,gBACA,kBAGA,cACA,OACA,OACA,YAEA,sBACA,qBAGA,oDACA,qBACA,iBACA,iBACA,iBACA,4BACA,aAAa,MACb,qBACA,eACA,uBAEA,wBACA,gBACA,6BAEA,oBACA,gBACA,mBAEA,4BACA,mBACA,yBAGA,uCACA,4CACA,SAEA,eACA,aAAa,MACb,6CAGA,WAEA,GAQA,mCA8IA,YACA,mCA9IA,SAEA,gBACA,kBAGA,cACA,OACA,OACA,YAEA,cACA,qBACA,aAAY,KACZ,eAIA,uBAIA,oDACA,qBACA,iBACA,iBACA,iBACA,4BACA,aAAa,MACb,qBACA,uBACA,uBAEA,wBACA,4BACA,6BAEA,oBACA,4BACA,iBAEA,4BACA,mBACA,yBAGA,+CACA,SAEA,eACA,aAAa,MACb,6CAGA,WAEA,GAOA,2BAgFA,6BACA,YACA,qCA5PA,SAEA,gBACA,kBAGA,cACA,OACA,OACA,KACA,OACA,OACA,SACA,QACA,cAAgB,cAAgB,KAChC,gBAEA,+BACA,gBACA,cACA,MACA,kBACA,iB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,EAC/B,eACA,cAGA,QACA,KAOA,6BACA,kBACA,0BACA,gDACA,gBACA,oBACA,iBAAmB,IAAO,EAC1B,cAEA,SACA,EAMA,8BACA,gBACA,uBACA,uDACA,mBAEA,wHACA,kBAEA,WACA,OACA,QAAe,IAAO,MACtB,OAAmB,IAAO,EAC1B,cAEA,SAAmB,IAAO,MAC1B,YAEA,KACA,QAAuB,IAAO,EAC9B,cAEA,WACA,CACA,CACA,OACA,EAOA,kCACA,oBAAmC,OAAQ,EAC3C,iBAEA,SACA,KAOA,qCACA,oBAAsC,UAAQ,EAC9C,4CAEA,UACA,KAMA,kCACA,+BACA,yBACA,kBAAmB,IAAQ,EAC3B,cAAuB,IAAQ,EAC/B,oBAGA,SACA,EAUA,yCACA,uFACA,6BACA,+CACA,aAA0B,KAAa,EACvC,cAAiC,KAAgB,EACjD,wBAGA,SACA,EASA,0CACA,IACA,yBACA,iBACK,GACL,uCAEA,2CACA,6BACA,gDACA,mBACA,aAAmB,IAAO,EAC1B,cAAiC,KAAgB,MACjD,kBACA,uBACA,+CACA,EAEA,OACA,EASA,6CACA,IACA,yBACA,cACK,GACL,oCAEA,wCACA,0BACA,gDACA,sBACA,aAAmB,IAAO,EAC1B,cAA8B,KAAa,MAC3C,kBACA,uBACA,8CACA,GAEA,OACA,EAMA,8BACA,UACA,+BACA,4BACU,uBAAV,OAAiB,EACjB,eAEA,SACA,EAMA,4BACA,wBACA,kBAAmB,IAAQ,EAC3B,cAAuB,IAAQ,EAC/B,gCAGA,GAEA,8BC77CA,CAEA,0BASA,oBACA,MAEA,gBAKA,sDACA,EAEA,SAlBA,OACA,OACA,QACA,QACA,QAEA,kCAKA,UACA,KAEA,+BAKA,eACA,EAEA,YACA,4BACA,MACA,0BACA,MACA,kBACA,KACA,kBACA,KACA,wBACA,MACA,UACA,QACA,mBCvCA,CAEA,4BAKA,qBACA,mBAEA,mBAEA,KAEA,cACA,YACA,SACA,qBAEA,QACA,YACA,6BACA,aACA,8BACA,mBAEA,cACA,UACA,MACA,eACS,8FACT,KACA,gBACA,SACA,QACA,WACA,IACA,IACA,CAGA,mCAUA,8BAEA,wBAXA,gBACA,eACA,WACA,YAEA,mBACA,8BAEA,4BAGyC,OAAS,QAClD,UACA,WACA,KAAuB,MAAO,EAC9B,yBAEA,kBACA,KACA,uBAEA,QAA2B,MAAO,EAClC,kBAEA,eACA,CACA,UACA,GAEA,WAAuB,KAAO,OAC9B,qBACA,QACA,KAA2B,MAAO,EAClC,yBAEA,qBACA,OAA2B,MAAO,EAClC,yBAEA,GACA,aACA,GAEA,UACA,UAAuB,MAAO,EAC9B,qBAIA,aACA,WACA,QAA2B,KAAO,EAClC,qBAEA,kBACA,KACA,qBACA,WAA+B,KAAO,EACtC,cAEA,aACA,CACA,aACA,sBACA,WAA+B,KAAO,EACtC,YAEA,YAA+B,KAAO,EACtC,eAAmC,KAAO,EAC1C,yBAGA,cAA+B,KAAO,EACtC,wBACA,SAAmC,KAAO,EAC1C,sBAGA,GACA,IACA,YAA+B,KAAO,EACtC,iBAGA,GACA,CAEA,oBACA,MACA,gBAEA,OACA,aAEA,QACA,oBAEA,YAEA,IACA,QAAqB,MAAQ,OAC7B,QAAuB,KAAO,EAC9B,eAEA,YACA,CACA,WAAyB,EAAQ,MACjC,kBACA,WAA+B,KAAQ,OACvC,QACA,KAA+B,MAAO,EACtC,yBAEA,qBACA,OAA+B,MAAO,EACtC,yBAEA,GACA,QAA2B,MAAO,EAClC,sBAEA,0BACA,OAA2B,QAAW,EACtC,eAEA,CAAa,KACb,QAA2B,KAAO,EAClC,eAEA,YACA,CAEA,CAEA,IACA,WAAuB,EAAQ,WAC/B,WACA,oBAA+B,KAAO,OACtC,QACA,QAAmC,KAAO,EAC1C,yBAEA,uBACA,UAAmC,KAAO,EAC1C,yBAEA,GAEA,QAAuB,KAAO,EAC9B,eAEA,YACA,CAGA,eACA,KACA,iBACA,UACA,WAAuB,GAAS,QAIhC,OAHA,gEAIA,OACA,EACA,KAEA,YACA,KACS,MACT,WAA4B,MAAS,SAIrC,GAHA,kDAIA,4CACA,OACA,EACA,KAEA,MACA,MACa,UACb,KAEA,MACA,KAEA,GAEA,QAEA,KACA,WACA,aACA,WACA,QAA+B,MAAQ,GACvC,mBACA,aACA,SACA,SACA,QACA,iBACA,mBAEA,IACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAIA,GACA,KACA,QACA,aACA,WACA,KAA2B,MAAO,GAClC,mBACA,aACA,SACA,SACA,YACA,eACA,IACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAIA,GACA,KACA,QACA,gIACA,iBACA,cACA,cACA,YACA,YACA,8BACA,eACA,OACA,WACA,6BACA,IACA,WAEA,cAEA,wBACA,SACA,MAA2B,SAAW,OACtC,YACA,UACA,SACA,QACA,aAEA,qBACA,wBACA,eACA,mBACA,GACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAGA,cACA,UACA,SACA,SACA,uBACA,6BACA,cACA,mBACA,WACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAGA,EACA,SACA,SACA,EACA,KACA,QACA,IACA,gCACA,EACA,UAAmC,MAAS,GAC5C,sBAIA,YACA,kBAGA,cACA,eACA,WACA,WACA,SAAmC,KAAO,EAC1C,iBACA,qBACA,cAGA,cACA,SAAmC,KAAO,EAC1C,iBACA,qBACA,cAGA,GAEA,QACA,EACA,KACA,KAEA,EAEA,MACA,QACA,IACA,IACA,EAEA,QACA,SACA,SACA,SACA,SACA,CAEA,SAhYA,UAGA,uBA8XA,gBACA,iDACA,EACA,aACA,eACA,EACA,YACA,mBACA,wCACA,IACA,SACA,kBAAsC,SAAQ,EAC9C,SACA,GAGA,UACA,EACA,gBACA,aACA,CAEA,iBACA,yDACA,EACA,2BACA,aACA,CACA,4BACA,aACA,CACA,sBACA,oBACA,EACA,mBAEA,IAMA,UAJA,mBACA,mBACA,SAEmB,IAAW,EAC9B,iCACA,EAEA,WAKA,WAMA,gBALA,YACA,cACA,iBACA,SAEmB,IAAW,EAC9B,UAAuB,IAAW,MAClC,OACA,IAA2B,IAAW,EACtC,yBAEA,WACA,CAGA,UACA,KA/BA,EAgCA,8BACA,0BACA,GACA,oBACA,OAMA,SALA,mBACA,cACA,yBACA,cAEmB,IAAW,EAC9B,UAAuB,IAAW,EAClC,gCACA,sBAEA,GAKA,QAKA,WAJA,cACA,kBACA,SAEmB,IAAW,EAC9B,UAAuB,IAAW,MAClC,OACA,IAA2B,IAAW,EACtC,yBAEA,WACA,CAGA,OACA,EAGA,6BChfA,CAEA,uCACA,IACA,+BACA,QACA,4BAEA,IACA,MAIA,OAHA,4BAEA,qBCZA,CAEA,0BAKA,qBACA,iBAEA,sBACA,MACA,2BAGA,uCAOA,MANA,oBACA,WACA,WACA,KACA,qBAGA,OAAmB,IAAO,EAC1B,UAAuB,IAAO,EAC9B,iBAGA,WACA,WACA,EACA,KACA,iBACA,WACA,SAAmB,IAAO,EAC1B,UAAuB,IAAO,EAC9B,iBAGA,WACA,aACA,EAEA,QACA,SACA,SACA,SACA,CAEA,oBAkCA,eACA,KAEA,SAAe,IAAO,EACtB,gBAGA,WAAmB,EAAO,QAC1B,QACA,IACA,IAAmB,IAAO,EAC1B,qBAGA,OACA,oBACA,KAAuB,IAAO,EAC9B,gBACA,WACA,UAES,MACT,OAAuB,IAAO,EAC9B,UACA,aAGA,aACA,eACA,GACA,SAGA,WACA,QACA,WACA,IAAuB,IAAO,EAC9B,SAGA,QAAuB,IAAO,MAC9B,SACA,WACA,iBACA,MAA+B,OAAY,EAC3C,iBACA,iBAEA,OACA,CAEA,OACA,IAAuB,IAAO,EAC9B,UACA,YAGA,eACA,KAAuB,IAAO,EAC9B,eAGA,SAAuB,IAAO,MAC9B,SACA,OACA,KAA2B,OAAY,EACvC,wBAEA,eACA,WACA,CACA,CACA,MACA,CAEA,OAAe,MAAW,MAC1B,mBACA,WACA,QACA,SACA,OAAuB,KAAQ,EAC/B,mBAGA,QAAuB,KAAQ,MAC/B,OACA,IAA2B,KAAQ,EACnC,sBAEA,SAA2B,KAAQ,EACnC,iBAEA,EACA,CAEA,OAAmB,KAAQ,EAC3B,cAEA,CAEA,OAAe,IAAO,EACtB,gBACA,aAGA,cACA,OACA,CAEA,oBAEA,uBACA,qBACA,GAEA,SAAe,IAAO,EACtB,aAGA,UAEA,SACA,KACA,iBAEA,UAAe,IAAO,MACtB,8CACA,QACA,KACA,yBAGA,KAGA,aACA,IACA,IACA,WAEA,MACA,sBACA,YACA,GACA,WAGA,kBACA,oBACA,WACA,SACA,OAA+B,IAAO,EACtC,UAGA,YAEA,OACA,OACA,KACA,MACA,UACA,MACA,KACA,OAA+B,KAAQ,EACvC,WACA,MACA,MACA,UACA,QACA,aACA,cACA,WACA,SACA,iBACA,yBAEA,MAA+B,IAAO,EACtC,aACA,2BACA,wBAIA,uBACA,WACA,WAEA,EACA,yBACA,GACA,WACA,QACA,CAEA,OAAe,MAAW,MAC1B,OACA,OACA,OAAuB,IAAO,EAC9B,SACA,OACA,OAIA,WACA,aACA,QACA,KAAuB,IAAO,EAC9B,YACA,gBACA,WAGA,EACA,CAEA,oBAEA,gBAGA,GAEA,KAJA,MACA,WAGqB,QAAe,OACpC,QACA,IAAmB,MAAW,EAC9B,2BAGA,cACA,OACA,IAA0B,KAAQ,GAClC,oBACA,aAGA,mBACA,GACA,aAGA,aACA,cAEA,KAAuB,MAAO,OAC9B,OACA,IAA8B,KAAQ,GACtC,iBAGA,YACA,IAA2B,MAAW,EACtC,kBAEA,EAEA,OAAuB,KAAW,MAClC,OACA,KAA8B,MAAQ,GACtC,mBAGA,YACA,KAA2B,OAAW,EACtC,mBAEA,GAEA,YACA,mBACA,CACA,CAEA,OAAe,IAAO,EACtB,WAAmB,KAAO,EAC1B,uBAIA,WAAsB,QAAc,EACpC,wBACA,UAA2B,KAAW,EACtC,iBAGA,UAAuB,OAAW,OAClC,OACA,IAA2B,MAAW,EACtC,iBAGA,2BACA,KAA2B,MAAW,EACtC,kBAEA,EACA,CAEA,CAEA,sBACA,6BAaA,YACA,MAEA,OAfA,IACA,MACA,gBACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,SAIe,KAAQ,EACvB,mBACA,iBACA,UAGA,oBAAoC,MAAQ,EAC5C,0BAIA,gBACA,QACA,KACA,8CACA,KACA,WAEA,8BAGA,MAGA,aACA,kBACA,YACA,QACA,EACA,OACS,mBACT,wBACA,4BACA,WACA,yBACA,qBACA,0BACA,UAEA,SACA,uBACA,aACA,YACA,GACA,mBAEA,WACA,OACA,YACA,4BACA,UACA,SACA,yBACA,UACA,SAEA,QAA+B,KAAQ,EACvC,eACA,6BACA,4BAGA,UAA2B,MAAQ,EACnC,gBACA,6BACA,2BAGA,UAA6B,MAAW,EACxC,gBACA,6BACA,2BAEA,EACA,gBACA,WACA,UACA,SAGA,OACA,KACA,CAAS,KACT,YACA,MACA,KACA,KACA,gBACA,uBAGA,WACA,QACA,MAA6B,MAAQ,EACrC,gBAEA,4CACA,eACA,iBACA,EAEA,IACA,oBACA,WACA,SACA,kBACA,OACA,SAEA,wBACA,OAAiC,MAAQ,EACzC,gBAEA,MACA,YACA,KAGA,WAEA,OACA,MACA,cACA,UACA,SACA,sCACA,0BACA,iBACA,yCACA,UACA,SACA,SACA,OAGA,mIAGA,QAGA,eAA2B,MAAQ,EACnC,iBACA,QACA,gBAIA,UAAuB,SAAY,cAEnC,MACA,iBACA,iBACA,uBACA,wCACA,IACA,eACA,SACA,SAIA,KAIA,QAjBA,oCAkBA,IACA,WAGA,WACA,SACA,QAEA,2BAGA,oBAJqB,SAKrB,SACA,SACA,SACA,SACA,SAEA,MAA+B,MAAQ,EACvC,6BACA,IACA,sBACA,+BAGA,2BACA,8BAGA,UAA+B,oBAAyB,GACxD,iCACA,GACA,uBACA,8BAGA,wBACA,8BAGA,UAAiC,MAAW,EAC5C,iCACA,GACA,uBACA,8BAGA,wBACA,8BAEA,EAEA,CACA,CAEA,IAIA,gBAAoB,EAAQ,KAC5B,YACA,QAEA,GACA,cACA,UACA,OAA2B,EAAQ,WACnC,kBACA,MACA,KAA2B,OAAQ,EACnC,2BAGA,MACA,WACA,MAEA,cACA,GACA,iCAEA,wBACA,cACA,qCACA,qBACA,YACA,mEAGA,sBACA,IACA,iBAAmC,OAAQ,EAC3C,uBAIA,EACS,SACT,cAEA,sCACA,2BACA,kCAEA,sCACA,mBACA,gBAGA,cACA,UACA,OAA2B,EAAQ,WACnC,QACA,KACA,KAA2B,OAAQ,EACnC,6BACA,yBAGA,mBAEA,GACA,WACA,MACA,MAEA,cACA,GACA,2BACA,kBACA,eAEA,iBACA,cACA,4CACA,mBACA,WACA,+EAEA,kDACA,kBACA,eACA,sCACA,kDACA,8CAEA,+CACA,oBACA,iBAIA,qDACA,KACA,iBAAmC,OAAQ,EAC3C,2BACA,qBAI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CACA,oBACA,kBACA,aAAmB,IAAQ,EAC3B,cAAuB,IAAQ,EAC/B,0BAIA,UACA,EAEA,EAsDA,oBA3OA,gBACA,EAEA,EAyOA,kBAxOA,iBACA,EAEA,EAsOA,mBAjOA,kBACA,EAEA,EA+NA,oBA9NA,iBACA,EAEA,EA4NA,iBAvOA,gBACA,EAEA,mBCvBA,CAEA,0BAsOA,WACA,MACA,iBAAmB,IAAY,IAC/B,OAEA,MACA,cACA,aAAmB,IAAY,IAC/B,qBACA,YACA,SACA,kBAEA,6BAGA,OACA,CAEA,kBACA,aACA,YAAmB,MAAqB,OACxC,WAEA,cACA,cACA,GAEA,cACA,gBACA,GAEA,gBACA,gBACA,MAEA,cACA,gBACA,QAKA,aACA,oBACA,cACA,yBACA,sBACA,wBACA,uBAGA,6BACA,mCAGA,EAEA,WA/RA,QAEA,MACA,WACA,YACA,aAEA,eACA,mBACA,EACA,eACA,WACA,iCACA,EACA,mCAwBA,4BACA,GAAuB,OACvB,WACA,4BAEA,0BAEA,IAGA,KAFA,WACA,qBACuB,cAAkB,IACzC,wBACA,OACA,MAEA,KACA,MAIA,gBACA,eAEA,GAEA,CACA,UAAyB,QACzB,cACA,mBACA,QAGA,cAAmB,OAAc,OACjC,uBAGA,aAAmB,OAAc,OACjC,KACA,gBAIA,SAEA,IADA,EAEA,gBACA,2BAAoC,2DACpC,sBAAiC,2DACjC,qBAAkC,2DAElC,QACA,mBAA0B,2DAC1B,cAAuB,2DACvB,aAAwB,2DAGxB,cACA,YACA,UACA,KACA,aAAmB,OAAc,OACjC,qBACA,mBAEA,sBACA,mBAIA,aACA,QACA,uBACA,cACA,mBACA,0BACA,MACA,KACA,KACA,KAEA,aAAmB,cAAkB,IAGrC,qBAGA,kDACA,+BACA,SACA,MACA,UAEA,UACA,oBACA,YAKA,iCACA,+BACA,SACA,MACA,UAEA,UACA,oBACA,YAMA,gCAEA,cACA,0CAGA,cACA,aACA,aACA,aAEA,mBAIA,eAHA,WACA,MACA,aACmB,QAAmB,YACtC,UACA,SACA,YACA,gBACA,aACA,EACA,6BACA,uCAGA,MACA,MAEA,GAEA,qCACA,OACA,MAEA,MAGA,OACA,0CACA,cACA,UACA,MACA,uBACA,iCACA,WAEA,OACA,8BACA,sBAEA,qBACA,iBACA,mBACA,0DACA,EAGA,CACA,WAEA,KACA,0BAGA,cAAmB,QAAoB,OACvC,mBAGA,yCACA,gBACA,CAEA,GAEA,EAEA,gBCvOA,CAEA,oCACA,kCAEA,sBACA,OACA,+CAGA,GACA,4BAEA,eACA,QACA,8BAGA,wBACA,wFAEA,wCACA,EAMA,qBAEA,0CACA,EAEA,wBACA,eACA,cACA,KACA,cACA,OAGA,KASO,IARP,uBACA,cAEA,SACE,8CACF,WAGA,QAAmB,IACnB,iBAEA,GAEA,gBACA,OACA,OAGA,OAEA,sBACA,MACA,GACA,eAEA,gBAIA,gBAGM,IACN,6BAQA,UACA,oBCnFA,oBA4EA,OACA,IACA,gBAA0B,MAC1B,qBACA,gBACA,GAGA,yBACA,EAEA,oBACA,OACA,WACA,uCACA,2DAGA,SACA,KAGA,EAIA,EACA,CAEA,gBACA,OACA,QACA,kBAAwB,KACxB,OAGA,QACA,EAEA,sBACA,OACA,cAAgB,KAEhB,4DAEA,SACA,EAQA,kBACA,aACA,kBACA,gBAAkB,KAAM,IACxB,cACA,gBAAsB,KACtB,0BAEA,EACA,OACA,EA0BA,SArKA,MAEA,UACA,YACA,aACA,aAIA,4BACA,MAAuB,OAEvB,0DACA,iCAGA,uFACA,6FACA,+CACA,iCACA,kFACA,iCACA,2CACA,yBAGA,wKAEA,0BACA,OACA,eACA,wBACA,cACA,EACA,KACA,qDAGA,oBAIA,yBAAgB,KAAO,KACvB,eACA,aACA,WACA,aAAuB,KAAgB,EACvC,kBACA,wBAEA,GACA,gBACA,eAGA,qBACA,yBACA,mBACA,yBAEA,EAEA,UACA,gBAAyB,OAAO,KAChC,QACA,aAAuB,KAAgB,EACvC,wBACA,GACA,qBACA,0BACA,CACA,OACA,EAEA,kBC5EA,CAEA,uBACA,iCCHA,CAEA,4BACA,UACA,CAOA,kBACA,OACA,YAAmB,MAAmB,OACtC,SAEA,SACA,EAOA,mBACA,OACA,WACA,iBAAmB,IAAO,EAC1B,iBAEA,UACA,EAOA,mBACA,IACA,WACA,iBAAmB,IAAO,EAC1B,iBAEA,UACA,EAOA,sBACA,IACA,SACA,WACA,iBAAmB,IAAO,EAC1B,iBACA,iBAEA,UACA,KACA,MAEA,EAOA,8BACA,OACA,MACA,iBAAmB,IAAO,EAC1B,SAEA,YACA,CAKA,WAOA,0CACA,OACA,MACA,iBAAmB,IAAO,EAC1B,SAEA,uBACA,EASA,uBACA,OACA,MACA,iBAAmB,IAAO,EAC1B,kBAEA,aACA,CAQA,2BACA,OACA,IACA,MACA,iBAAmB,IAAO,EAC1B,cACA,QAEA,YACA,CASA,iCACA,cACA,MACA,qBAEA,YACA,sBACA,KACA,YAAmB,MAAa,EAChC,SAEA,iBACA,EAOA,4BACA,OACA,MACA,iBAAmB,IAAO,MAC1B,IACA,kDAEA,kBACA,EACA,UACA,CAOA,kCACA,OACA,IACA,MACA,iBAAmB,IAAO,EAC1B,cACA,QAEA,MACA,yBAEA,sCACA,CAQA,wBACA,cACA,MACA,qBAEA,YACA,sBACA,SACA,QAEA,oBAEA,EAQA,0BACA,cACA,mBACA,KACA,MAEA,iBAAmB,IAAO,MAC1B,YACA,OACA,CAEA,OACA,QAEA,KAEA,CAQA,mCACA,+BACA,GAEA,6BACA,2CACA,OAEA,2BACA,yBACA,MACA,QACA,eAGA,mBACA,mBACA,cACA,yBAEA,UAAY,aACZ,EAEA,yCACA,qCACA,GAEA,gCACA,yBACA,YACA,UACA,iBAAmB,IAAO,MAC1B,SACA,gBAEA,mBAEA,KACA,WAEA,IACA,MACA,UACA,CAEA,oBACA,IAGA,OAFA,eACA,SACe,IAAO,EACtB,SAEA,cACA,KAEA,QAAe,IAAO,MACtB,mBACA,IACA,OAEA,aACA,QACA,EAEA,IAEA,WACA,QAAe,IAAW,EAC1B,SACA,QACA,KAIA,YACA,EAEA,8BACA,yBACA,mBACA,YAEA,mBACA,YAEA,sDACA,iBAAmB,IAAO,MAC1B,YACA,SACA,OACA,CAEA,OACA,QAEA,KACA,CAEA,0BACA,yBACA,mBAEA,eACA,iBAAmB,IAAO,MAC1B,YACA,OACA,SACA,CACA,SACA,MAEA,mBACA,QACA,sBACA,gBACA,GACA,CAEA,OAEA,EAEA,0BACA,yBACA,mBACA,oBAEA,YAAmB,IAAO,MAC1B,YACA,OACA,WACA,CACA,SACA,MAEA,OACA,YACA,UAEA,kCADA,MAIA,yBADA,IAGA,gBAEA,CAEA,yBACA,2BACA,eACA,iBAAmB,IAAO,EAC1B,0BACA,UACA,CAEA,8BACA,aACA,iBAAmB,IAAO,EAC1B,cACA,SACA,EAEA,2CACA,uCACA,GAEA,kCACA,wBACA,WACA,aAEA,YAAmB,IAAO,MAC1B,YACA,MAEA,WACA,MACA,OACA,CAEA,kBACA,GAEA,wBACA,yBAEA,YACA,EACA,QAEA,6BACA,iBAAmB,IAAO,EAC1B,UACA,CAEA,+BACA,+CACA,4BACA,cACA,mBACA,aAAmB,IAAO,EAC1B,cACA,QACA,EAEA,6BACA,SACA,eACA,UACA,aAAmB,IAAO,EAC1B,kBACA,SACA,oBCpcA,CACA,4BAoBA,CACA,0BAEA,aAIA,MAHA,cACA,iBAGA,KACA,UACA,IAAmB,IAAU,EAC7B,UAAuB,IAAU,EACjC,eAGA,SACA,CAAK,SACL,kBACA,KACA,IAAmB,IAAU,MAC7B,UACA,IAAuB,IAAU,EACjC,eAEA,SACA,CACK,SACL,kBACA,KACA,IAAmB,IAAU,MAC7B,UACA,IAAuB,IAAU,EACjC,eAEA,SACA,CAEA,sBAEA,2BACA,EAEA,kBACA,oBACA,iBAAmB,IAAO,EAC1B,qBAEA,UACA,EAEA,kBACA,CACA,wBAEA,aACA,WACA,gBACA,oBACA,eAEA,aAAmB,IAAU,MAC7B,iBACA,aAAuB,KAAU,EACjC,mBACA,MACA,UAEA,QACA,gBAEA,cAEA,CACA,OACA,EAEA,kBAoIA,CACA,0BAEA,GACA,wBACA,iBACS,EACT,qBAGA,cACA,OACA,UACA,MAEA,yBAGA,UAFA,gBAGA,aACA,KAAmB,IAAU,EAC7B,eAEA,SAAmB,IAAU,EAC7B,WAAuB,KAAU,OACjC,QACA,KAA2B,KAAU,EACrC,uCAEA,QACA,WACA,YACA,EAEA,CAAK,eACL,aACA,KAAmB,IAA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","file":"ml-gsd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GSD\"] = factory();\n\telse\n\t\troot[\"GSD\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 291484932c94a4c31894","'use strict';\n\nmodule.exports.post = require('../src/optimize');\nmodule.exports.gsd = require('../src/gsd');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","/**\n * Created by acastillo on 9/6/15.\n */\n'use strict';\n\nvar Opt = require('ml-optimize-lorentzian');\n\nfunction sampleFunction(from, to, x, y, lastIndex) {\n    var nbPoints = x.length;\n    var sampleX = [];\n    var sampleY = [];\n    var direction = Math.sign(x[1] - x[0]);//Direction of the derivative\n    if (direction === -1) {\n        lastIndex[0] = x.length - 1;\n    }\n\n    var delta = Math.abs(to - from) / 2;\n    var mid = (from + to) / 2;\n    var stop = false;\n    var index = lastIndex[0];\n    while (!stop && index < nbPoints && index >= 0) {\n        if (Math.abs(x[index] - mid) <= delta) {\n            sampleX.push(x[index]);\n            sampleY.push(y[index]);\n            index += direction;\n        } else {\n            //It is outside the range.\n            if (Math.sign(mid - x[index]) === 1) {\n                //We'll reach the mid going in the current direction\n                index += direction;\n            } else {\n                //There is not more peaks in the current range\n                stop = true;\n            }\n        }\n        //console.log(sampleX);\n    }\n    lastIndex[0] = index;\n    return [sampleX, sampleY];\n}\n\nfunction optimizePeaks(peakList, x, y, n, fnType) {\n    var i, j, lastIndex = [0];\n    var groups = groupPeaks(peakList, n);\n    var result = [];\n    var factor = 1;\n    if (fnType === 'gaussian')\n        factor = 1.17741;//From https://en.wikipedia.org/wiki/Gaussian_function#Properties\n    var sampling, error, opts;\n    for (i = 0; i < groups.length; i++) {\n        var peaks = groups[i].group;\n        if (peaks.length > 1) {\n            //Multiple peaks\n            //console.log(\"Pending group of overlaped peaks \"+peaks.length);\n            //console.log(\"here1\");\n            //console.log(groups[i].limits);\n            sampling = sampleFunction(groups[i].limits[0] - groups[i].limits[1], groups[i].limits[0] + groups[i].limits[1], x, y, lastIndex);\n            //console.log(sampling);\n            if (sampling[0].length > 5) {\n                error = peaks[0].width / 1000;\n                opts = [  3,    100, error, error, error, error * 10, error * 10,    11,    9,        1 ];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                var optPeaks = [];\n                if (fnType === 'gaussian')\n                    optPeaks = Opt.optimizeGaussianSum(sampling, peaks, opts);\n                else {\n                    if (fnType === 'lorentzian') {\n                        optPeaks = Opt.optimizeLorentzianSum(sampling, peaks, opts);\n                    }\n                }\n                //console.log(optPeak);\n                for (j = 0; j < optPeaks.length; j++) {\n                    result.push({x: optPeaks[j][0][0], y: optPeaks[j][1][0], width: optPeaks[j][2][0] * factor});\n                }\n            }\n        } else {\n            //Single peak\n            peaks = peaks[0];\n            sampling = sampleFunction(peaks.x - n * peaks.width,\n                peaks.x + n * peaks.width, x, y, lastIndex);\n            //console.log(\"here2\");\n            //console.log(groups[i].limits);\n            if (sampling[0].length > 5) {\n                error = peaks.width / 1000;\n                opts = [3, 100, error, error, error, error * 10, error * 10, 11, 9, 1];\n                //var gauss = Opt.optimizeSingleGaussian(sampling[0], sampling[1], opts, peaks);\n                //var gauss = Opt.optimizeSingleGaussian([sampling[0],sampling[1]], peaks, opts);\n                var optPeak = [];\n                if (fnType === 'gaussian')\n                    optPeak = Opt.optimizeSingleGaussian([sampling[0], sampling[1]], peaks,  opts);\n                else {\n                    if (fnType === 'lorentzian') {\n                        optPeak = Opt.optimizeSingleLorentzian([sampling[0], sampling[1]], peaks,  opts);\n                    }\n                }\n                //console.log(optPeak);\n                result.push({x: optPeak[0][0], y: optPeak[1][0], width: optPeak[2][0] * factor}); // From https://en.wikipedia.org/wiki/Gaussian_function#Properties}\n            }\n        }\n\n    }\n    return result;\n}\n\nfunction groupPeaks(peakList, nL) {\n    var group = [];\n    var groups = [];\n    var i, j;\n    var limits = [peakList[0].x, nL * peakList[0].width];\n    var upperLimit, lowerLimit;\n    //Merge forward\n    for (i = 0; i < peakList.length; i++) {\n        //If the 2 things overlaps\n        if (Math.abs(peakList[i].x - limits[0]) < (nL * peakList[i].width + limits[1])) {\n            //Add the peak to the group\n            group.push(peakList[i]);\n            //Update the group limits\n            upperLimit = limits[0] + limits[1];\n            if (peakList[i].x + nL * peakList[i].width > upperLimit) {\n                upperLimit = peakList[i].x + nL * peakList[i].width;\n            }\n            lowerLimit = limits[0] - limits[1];\n            if (peakList[i].x - nL * peakList[i].width < lowerLimit) {\n                lowerLimit = peakList[i].x - nL * peakList[i].width;\n            }\n            limits = [(upperLimit + lowerLimit) / 2, Math.abs(upperLimit - lowerLimit) / 2];\n\n        } else {\n            groups.push({limits: limits, group: group});\n            //var optmimalPeak = fitSpectrum(group,limits,spectrum);\n            group = [peakList[i]];\n            limits = [peakList[i].x, nL * peakList[i].width];\n        }\n    }\n    groups.push({limits: limits, group: group});\n    //Merge backward\n    for (i = groups.length - 2; i >= 0; i--) {\n        //The groups overlaps\n        if (Math.abs(groups[i].limits[0] - groups[i + 1].limits[0]) <\n            (groups[i].limits[1] + groups[i + 1].limits[1]) / 2) {\n            for (j = 0; j < groups[i + 1].group.length; j++) {\n                groups[i].group.push(groups[i + 1].group[j]);\n            }\n            upperLimit = groups[i].limits[0] + groups[i].limits[1];\n            if (groups[i + 1].limits[0] + groups[i + 1].limits[1] > upperLimit) {\n                upperLimit = groups[i + 1].limits[0] + groups[i + 1].limits[1];\n            }\n            lowerLimit = groups[i].limits[0] - groups[i].limits[1];\n            if (groups[i + 1].limits[0] - groups[i + 1].limits[1] < lowerLimit) {\n                lowerLimit = groups[i + 1].limits[0] - groups[i + 1].limits[1];\n            }\n            //console.log(limits);\n            groups[i].limits = [(upperLimit + lowerLimit) / 2, Math.abs(upperLimit - lowerLimit) / 2];\n\n            groups.splice(i + 1, 1);\n        }\n    }\n    return groups;\n}\n/**\n * This function try to join the peaks that seems to belong to a broad signal in a single broad peak.\n * @param peakList\n * @param options\n */\nfunction joinBroadPeaks(peakList, options) {\n    var width = options.width;\n    var broadLines = [];\n    //Optimize the possible broad lines\n    var max = 0, maxI = 0, count = 1;\n    for (let i = peakList.length - 1; i >= 0; i--) {\n        if (peakList[i].soft) {\n            broadLines.push(peakList.splice(i, 1)[0]);\n        }\n    }\n    //Push a feak peak\n    broadLines.push({x: Number.MAX_VALUE});\n\n    var candidates = [[broadLines[0].x,\n                        broadLines[0].y]];\n    var indexes = [0];\n\n    for (let i = 1; i < broadLines.length; i++) {\n        //console.log(broadLines[i-1].x+\" \"+broadLines[i].x);\n        if (Math.abs(broadLines[i - 1].x - broadLines[i].x) < width) {\n            candidates.push([broadLines[i].x, broadLines[i].y]);\n            if (broadLines[i].y > max) {\n                max = broadLines[i].y;\n                maxI = i;\n            }\n            indexes.push(i);\n            count++;\n        } else {\n            if (count > 2) {\n                var fitted = Opt.optimizeSingleLorentzian(candidates,\n                    {x: broadLines[maxI].x, y: max, width: Math.abs(candidates[0][0] - candidates[candidates.length - 1][0])});\n                peakList.push({x: fitted[0][0], y: fitted[1][0], width: fitted[2][0], soft: false});\n\n            } else {\n                //Put back the candidates to the signals list\n                indexes.map(function (index) {\n                    peakList.push(broadLines[index]);\n                });\n            }\n            candidates = [[broadLines[i].x, broadLines[i].y]];\n            indexes = [i];\n            max = broadLines[i].y;\n            maxI = i;\n            count = 1;\n        }\n    }\n\n    peakList.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return peakList;\n\n}\n\n/*\n var isPartOf = true\nif(options.broadRatio>0){\n var broadLines=[[Number.MAX_VALUE,0,0]];\n //Optimize the possible broad lines\n var max=0, maxI=0,count=0;\n var candidates = [],broadLinesS=[];\n var isPartOf = false;\n\n for(var i=broadLines.length-1;i>0;i--){\n //console.log(broadLines[i][0]+\" \"+rangeX+\" \"+Math.abs(broadLines[i-1][0]-broadLines[i][0]));\n if(Math.abs(broadLines[i-1][0]-broadLines[i][0])<rangeX){\n\n candidates.push(broadLines[i]);\n if(broadLines[i][1]>max){\n max = broadLines[i][1];\n maxI = i;\n }\n count++;\n }\n else{\n isPartOf = true;\n if(count>30){ // TODO, an options ?\n isPartOf = false;\n //for(var j=0;j<signals.length;j++){\n //    if(Math.abs(broadLines[maxI][0]-signals[j][0])<rangeX)\n //       isPartOf = true;\n //    }\n //console.log(\"Was part of \"+isPartOf);\n }\n if(isPartOf){\n for(var j=0;j<candidates.length;j++){\n signals.push([candidates[j][0], candidates[j][1], dx]);\n }\n }\n else{\n var fitted =  Opt.optimizeSingleLorentzian(candidates,{x:candidates[maxI][0],\n width:Math.abs(candidates[0][0]-candidates[candidates.length-1][0])},\n []);\n //console.log(fitted);\n signals.push([fitted[0][0],fitted[0][1],fitted[0][2]]);\n }\n candidates = [];\n max = 0;\n maxI = 0;\n count = 0;\n }\n }\n }*/\n\nmodule.exports = {optimizePeaks: optimizePeaks, joinBroadPeaks: joinBroadPeaks};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/optimize.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar LM = require('ml-curve-fitting');\nvar math = LM.Matrix.algebra;\nvar Matrix = require('ml-matrix');\n\n/**\n * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian\n * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfLorentzians(t,p,c){\n    var nL = p.length/3,factor,i, j,p2, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        p2 = Math.pow(p[i+nL*2][0]/2,2);\n        factor = p[i+nL][0]*p2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=factor/(Math.pow(t[j][0]-p[i][0],2)+p2);\n        }\n    }\n    return result;\n}\n\n/**\n * This function calculates the spectrum as a sum of gaussian functions. The Gaussian\n * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: std's;\n * @param t Ordinate values\n * @param p Gaussian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction sumOfGaussians(t,p,c){\n    var nL = p.length/3,factor,i, j, cols = t.rows;\n    var result = Matrix.zeros(t.length,1);\n\n    for(i=0;i<nL;i++){\n        factor = p[i+nL*2][0]*p[i+nL*2][0]/2;\n        for(j=0;j<cols;j++){\n            result[j][0]+=p[i+nL][0]*Math.exp(-(t[i][0]-p[i][0])*(t[i][0]-p[i][0])/factor);\n        }\n    }\n    return result;\n}\n/**\n * Single 4 parameter lorentzian function\n * @param t Ordinate values\n * @param p Lorentzian parameters\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleLorentzian(t,p,c){\n    var factor = p[1][0]*Math.pow(p[2][0]/2,2);\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));\n    }\n    return result;\n}\n\n/**\n * Single 3 parameter gaussian function\n * @param t Ordinate values\n * @param p Gaussian parameters [mean, height, std]\n * @param c Constant parameters(Not used)\n * @returns {*}\n */\nfunction singleGaussian(t,p,c){\n    var factor2 = p[2][0]*p[2][0]/2;\n    var rows = t.rows;\n    var result = new Matrix(t.rows, t.columns);\n    for(var i=0;i<rows;i++){\n        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);\n    }\n    return result;\n}\n\n/**\n * * Fits a set of points to a Lorentzian function. Returns the center of the peak, the width at half height, and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleLorentzian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];\n    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n\n    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n\n\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n\n}\n\n/**\n * Fits a set of points to a gaussian bell. Returns the mean of the peak, the std and the height of the signal.\n * @param data,[y]\n * @returns {*[]}\n */\nfunction optimizeSingleGaussian(xy, peak, opts) {\n    opts = opts || {};\n    var xy2 = parseData(xy, opts.percentage||0);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n\n    var nbPoints = t.rows, i;\n\n\n\n    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];\n\n    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);\n    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];\n    var consts = [ ];                         // optional vector of constants\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;\n\n    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);\n    var p_init = new Matrix([[peak.x],[1],[peak.width]]);\n    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);\n    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);\n    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);\n    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);\n\n    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];\n}\n\n/*\n peaks on group should sorted\n */\nfunction optimizeLorentzianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*4;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*4;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleLorentzian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n\n}\n\nfunction optimizeGaussianTrain(xy, group, opts){\n    var xy2 = parseData(xy);\n    //console.log(xy2[0].rows);\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var currentIndex = 0;\n    var nbPoints = t.length;\n    var nextX;\n    var tI, yI, maxY;\n    var result=[], current;\n    for(var i=0; i<group.length;i++){\n        nextX = group[i].x-group[i].width*4;\n        //console.log(group[i]);\n        while(t[currentIndex++]<nextX&&currentIndex<nbPoints);\n        nextX = group[i].x+group[i].width*4;\n        tI = [];\n        yI = [];\n        while(t[currentIndex]<=nextX&&currentIndex<nbPoints){\n            tI.push(t[currentIndex][0]);\n            yI.push(y_data[currentIndex][0]*maxY);\n            currentIndex++;\n        }\n\n        current=optimizeSingleGaussian([tI, yI], group[i], opts);\n        if(current){\n            result.push({\"x\":current[0][0],\"y\":current[1][0],\"width\":current[2][0],\"opt\":true});\n        }\n        else{\n            result.push({\"x\":group[i].x,\"y\":group[i].y,\"width\":group[i].width,\"opt\":false});\n        }\n    }\n\n    return result;\n}\n\n\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeLorentzianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows, i;\n\n    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = 1;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;//-group[i].width/4;\n        p_min[i+nL][0] = 0;\n        p_min[i+2*nL][0] = group[i].width/4;\n\n        p_max[i][0] = group[i].x+dt;//+group[i].width/4;\n        p_max[i+nL][0] = 1.5;\n        p_max[i+2*nL][0] = group[i].width*4;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n\n    var dx = -Math.abs(t[0][0]-t[1][0])/10000;\n    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);\n    p_fit=p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n\n/**\n *\n * @param xy A two column matrix containing the x and y data to be fitted\n * @param group A set of initial lorentzian parameters to be optimized [center, heigth, half_width_at_half_height]\n * @returns {Array} A set of final lorentzian parameters [center, heigth, hwhh*2]\n */\nfunction optimizeGaussianSum(xy, group, opts){\n    var xy2 = parseData(xy);\n\n    if(xy2===null||xy2[0].rows<3){\n        return null; //Cannot run an optimization with less than 3 points\n    }\n\n    var t = xy2[0];\n    var y_data = xy2[1];\n    var maxY = xy2[2];\n    var nbPoints = t.rows,i;\n\n    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];\n    var k = nbPoints / math.sqrt(y_data.dot(y_data));\n    for(i=0;i<nbPoints;i++){\n        weight[i][0]=k;///(y_data[i][0]);\n        //weight[i][0]=k*(2-y_data[i][0]);\n    }\n\n    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);\n    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];\n    var consts = [ ];// optional vector of constants\n\n    var nL = group.length;\n    var p_init = new Matrix(nL*3,1);\n    var p_min =  new Matrix(nL*3,1);\n    var p_max =  new Matrix(nL*3,1);\n    var dx = new Matrix(nL*3,1);\n    var dt = Math.abs(t[0][0]-t[1][0]);\n    for( i=0;i<nL;i++){\n        p_init[i][0] = group[i].x;\n        p_init[i+nL][0] = group[i].y/maxY;\n        p_init[i+2*nL][0] = group[i].width;\n\n        p_min[i][0] = group[i].x-dt;\n        p_min[i+nL][0] = group[i].y*0.8/maxY;\n        p_min[i+2*nL][0] = group[i].width/2;\n\n        p_max[i][0] = group[i].x+dt;\n        p_max[i+nL][0] = group[i].y*1.2/maxY;\n        p_max[i+2*nL][0] = group[i].width*2;\n\n        dx[i][0] = -dt/1000;\n        dx[i+nL][0] = -1e-3;\n        dx[i+2*nL][0] = -dt/1000;\n    }\n    //console.log(t);\n    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);\n    p_fit = p_fit.p;\n    //Put back the result in the correct format\n    var result = new Array(nL);\n    for( i=0;i<nL;i++){\n        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];\n    }\n\n    return result;\n\n}\n/**\n *\n * Converts the given input to the required x, y column matrices. y data is normalized to max(y)=1\n * @param xy\n * @returns {*[]}\n */\nfunction parseData(xy, threshold){\n    var nbSeries = xy.length;\n    var t = null;\n    var y_data = null, x,y;\n    var maxY = 0, i,j;\n\n    if(nbSeries==2){\n        //Looks like row wise matrix [x,y]\n        var nbPoints = xy[0].length;\n        //if(nbPoints<3)\n        //    throw new Exception(nbPoints);\n        //else{\n        t = new Array(nbPoints);//new Matrix(nbPoints,1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints,1);\n        x = xy[0];\n        y = xy[1];\n        if(typeof x[0] === \"number\"){\n            for(i=0;i<nbPoints;i++){\n                t[i]=x[i];\n                y_data[i]=y[i];\n                if(y[i]>maxY)\n                    maxY = y[i];\n            }\n        }\n        else{\n            //It is a colum matrix\n            if(typeof x[0] === \"object\"){\n                for(i=0;i<nbPoints;i++){\n                    t[i]=x[i][0];\n                    y_data[i]=y[i][0];\n                    if(y[i][0]>maxY)\n                        maxY = y[i][0];\n                }\n            }\n\n        }\n\n        //}\n    }\n    else{\n        //Looks like a column wise matrix [[x],[y]]\n        var nbPoints = nbSeries;\n        //if(nbPoints<3)\n        //    throw new SizeException(nbPoints);\n        //else {\n        t = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        y_data = new Array(nbPoints);//new Matrix(nbPoints, 1);\n        for (i = 0; i < nbPoints; i++) {\n            t[i] = xy[i][0];\n            y_data[i] = xy[i][1];\n            if(y_data[i]>maxY)\n                maxY = y_data[i];\n        }\n        //}\n    }\n    for (i = 0; i < nbPoints; i++) {\n        y_data[i]/=maxY;\n    }\n    if(threshold){\n        for (i = nbPoints-1; i >=0; i--) {\n            if(y_data[i]<threshold) {\n                y_data.splice(i,1);\n                t.splice(i,1);\n            }\n        }\n    }\n    if(t.length>0)\n        return [(new Matrix([t])).transpose(),(new Matrix([y_data])).transpose(),maxY];\n    return null;\n}\n\nfunction sizeException(nbPoints) {\n    return new RangeError(\"Not enough points to perform the optimization: \"+nbPoints +\"< 3\");\n}\n\nmodule.exports.optimizeSingleLorentzian = optimizeSingleLorentzian;\nmodule.exports.optimizeLorentzianSum = optimizeLorentzianSum;\nmodule.exports.optimizeSingleGaussian = optimizeSingleGaussian;\nmodule.exports.optimizeGaussianSum = optimizeGaussianSum;\nmodule.exports.singleGaussian = singleGaussian;\nmodule.exports.singleLorentzian = singleLorentzian;\nmodule.exports.optimizeGaussianTrain = optimizeGaussianTrain;\nmodule.exports.optimizeLorentzianTrain = optimizeLorentzianTrain;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-optimize-lorentzian/src/index.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nmodule.exports = require('./LM');\nmodule.exports.Matrix = require('ml-matrix');\nmodule.exports.Matrix.algebra = require('./algebra');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-curve-fitting/src/index.js\n// module id = 3\n// module chunks = 0","/**\n * Created by acastillo on 8/5/15.\n */\nvar Matrix = require(\"ml-matrix\");\nvar math = require(\"./algebra\");\n\nvar DEBUG = false;\n/** Levenberg Marquardt curve-fitting: minimize sum of weighted squared residuals\n ----------  INPUT  VARIABLES  -----------\n func   = function of n independent variables, 't', and m parameters, 'p',\n returning the simulated model: y_hat = func(t,p,c)\n p      = n-vector of initial guess of parameter values\n t      = m-vectors or matrix of independent variables (used as arg to func)\n y_dat  = m-vectors or matrix of data to be fit by func(t,p)\n weight = weighting vector for least squares fit ( weight >= 0 ) ...\n inverse of the standard measurement errors\n Default:  sqrt(d.o.f. / ( y_dat' * y_dat ))\n dp     = fractional increment of 'p' for numerical derivatives\n dp(j)>0 central differences calculated\n dp(j)<0 one sided 'backwards' differences calculated\n dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n Default:  0.001;\n p_min  = n-vector of lower bounds for parameter values\n p_max  = n-vector of upper bounds for parameter values\n c      = an optional matrix of values passed to func(t,p,c)\n opts   = vector of algorithmic parameters\n parameter    defaults    meaning\n opts(1)  =  prnt            3        >1 intermediate results; >2 plots\n opts(2)  =  MaxIter      10*Npar     maximum number of iterations\n opts(3)  =  epsilon_1       1e-3     convergence tolerance for gradient\n opts(4)  =  epsilon_2       1e-3     convergence tolerance for parameters\n opts(5)  =  epsilon_3       1e-3     convergence tolerance for Chi-square\n opts(6)  =  epsilon_4       1e-2     determines acceptance of a L-M step\n opts(7)  =  lambda_0        1e-2     initial value of L-M paramter\n opts(8)  =  lambda_UP_fac   11       factor for increasing lambda\n opts(9)  =  lambda_DN_fac    9       factor for decreasing lambda\n opts(10) =  Update_Type      1       1: Levenberg-Marquardt lambda update\n 2: Quadratic update\n 3: Nielsen's lambda update equations\n\n ----------  OUTPUT  VARIABLES  -----------\n p       = least-squares optimal estimate of the parameter values\n X2      = Chi squared criteria\n sigma_p = asymptotic standard error of the parameters\n sigma_y = asymptotic standard error of the curve-fit\n corr    = correlation matrix of the parameters\n R_sq    = R-squared cofficient of multiple determination\n cvg_hst = convergence history\n\n Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. 22 Sep 2013\n modified from: http://octave.sourceforge.net/optim/function/leasqr.html\n using references by\n Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n Sam Roweis       http://www.cs.toronto.edu/~roweis/notes/lm.pdf\n Manolis Lourakis http://www.ics.forth.gr/~lourakis/levmar/levmar.pdf\n Hans Nielson     http://www2.imm.dtu.dk/~hbn/publ/TR9905.ps\n Mathworks        optimization toolbox reference manual\n K. Madsen, H.B., Nielsen, and O. Tingleff\n http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/3215/pdf/imm3215.pdf\n */\nvar LM = {\n\n    optimize: function(func,p,t,y_dat,weight,dp,p_min,p_max,c,opts){\n\n        var tensor_parameter = 0;\t\t\t// set to 1 of parameter is a tensor\n\n        var iteration  = 0;\t\t\t// iteration counter\n        //func_calls = 0;\t\t\t// running count of function evaluations\n\n        if((typeof p[0])!=\"object\"){\n            for(var i=0;i< p.length;i++){\n                p[i]=[p[i]];\n            }\n\n        }\n        //p = p(:); y_dat = y_dat(:);\t\t// make column vectors\n        var i,k;\n        var eps = 2^-52;\n        var Npar   = p.length;//length(p); \t\t\t// number of parameters\n        var Npnt   = y_dat.length;//length(y_dat);\t\t// number of data points\n        var p_old  = Matrix.zeros(Npar,1);\t\t// previous set of parameters\n        var y_old  = Matrix.zeros(Npnt,1);\t\t// previous model, y_old = y_hat(t;p_old)\n        var X2     = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var X2_old = 1e-2/eps;\t\t\t// a really big initial Chi-sq value\n        var J =  Matrix.zeros(Npnt,Npar);\n\n\n        if (t.length != y_dat.length) {\n            console.log('lm.m error: the length of t must equal the length of y_dat');\n\n            length_t = t.length;\n            length_y_dat = y_dat.length;\n            var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;\n            if (!tensor_parameter) {\n                return;\n            }\n        }\n\n        weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));\n        dp = dp || 0.001;\n        p_min   = p_min || math.multiply(Math.abs(p),-100);\n        p_max   = p_max || math.multiply(Math.abs(p),100);\n        c = c || 1;\n        // Algorithmic Paramters\n        //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType\n        opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];\n\n        var prnt          = opts[0];\t// >1 intermediate results; >2 plots\n        var MaxIter       = opts[1];\t// maximum number of iterations\n        var epsilon_1     = opts[2];\t// convergence tolerance for gradient\n        var epsilon_2     = opts[3];\t// convergence tolerance for parameter\n        var epsilon_3     = opts[4];\t// convergence tolerance for Chi-square\n        var epsilon_4     = opts[5];\t// determines acceptance of a L-M step\n        var lambda_0      = opts[6];\t// initial value of damping paramter, lambda\n        var lambda_UP_fac = opts[7];\t// factor for increasing lambda\n        var lambda_DN_fac = opts[8];\t// factor for decreasing lambda\n        var Update_Type   = opts[9];\t// 1: Levenberg-Marquardt lambda update\n        // 2: Quadratic update\n        // 3: Nielsen's lambda update equations\n\n        if ( tensor_parameter && prnt == 3 ) prnt = 2;\n\n\n        if(!dp.length || dp.length == 1){\n            var dp_array = new Array(Npar);\n            for(var i=0;i<Npar;i++)\n                dp_array[i]=[dp];\n            dp=dp_array;\n        }\n\n        // indices of the parameters to be fit\n        var idx   = [];\n        for(i=0;i<dp.length;i++){\n            if(dp[i][0]!=0){\n                idx.push(i);\n            }\n        }\n\n        var Nfit = idx.length;\t\t\t// number of parameters to fit\n        var stop = false;\t\t\t\t// termination flag\n\n        var weight_sq = null;\n        //console.log(weight);\n        if ( !weight.length || weight.length < Npnt )\t{\n            // squared weighting vector\n            //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;\n            //console.log(\"weight[0] \"+typeof weight[0]);\n            var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);\n            weight_sq = math.dotMultiply(tmp,tmp);\n        }\n        else{\n            //weight_sq = (weight(:)).^2;\n            weight_sq = math.dotMultiply(weight,weight);\n        }\n\n\n        // initialize Jacobian with finite difference calculation\n        //console.log(\"J \"+weight_sq);\n        var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n        //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);\n        //console.log(JtWJ);\n\n        if ( Math.max(Math.abs(JtWdy)) < epsilon_1 ){\n            console.log(' *** Your Initial Guess is Extremely Close to Optimal ***')\n            console.log(' *** epsilon_1 = ', epsilon_1);\n            stop = true;\n        }\n\n\n        switch(Update_Type){\n            case 1: // Marquardt: init'l lambda\n                lambda  = lambda_0;\n                break;\n            default:    // Quadratic and Nielsen\n                lambda  = lambda_0 * Math.max(math.diag(JtWJ));\n                nu=2;\n        }\n        //console.log(X2);\n        X2_old = X2; // previous value of X2\n        //console.log(MaxIter+\" \"+Npar);\n        //var cvg_hst = Matrix.ones(MaxIter,Npar+3);\t\t// initialize convergence history\n        var h = null;\n        while ( !stop && iteration <= MaxIter ) {\t\t// --- Main Loop\n            iteration = iteration + 1;\n            // incremental change in parameters\n            switch(Update_Type){\n                case 1:\t\t\t\t\t// Marquardt\n                    //h = ( JtWJ + lambda * math.diag(math.diag(JtWJ)) ) \\ JtWdy;\n                    //h = math.multiply(math.inv(JtWdy),math.add(JtWJ,math.multiply(lambda,math.diag(math.diag(Npar)))));\n                    h = math.solve(math.add(JtWJ,math.multiply(math.diag(math.diag(JtWJ)),lambda)),JtWdy);\n                    break;\n                default:\t\t\t\t\t// Quadratic and Nielsen\n                    //h = ( JtWJ + lambda * math.eye(Npar) ) \\ JtWdy;\n\n                    h = math.solve(math.add(JtWJ,math.multiply( Matrix.eye(Npar),lambda)),JtWdy);\n            }\n\n            /*for(var k=0;k< h.length;k++){\n             h[k]=[h[k]];\n             }*/\n            //console.log(\"h \"+h);\n            //h=math.matrix(h);\n            //  big = max(abs(h./p)) > 2;\n            //this is a big step\n            // --- Are parameters [p+h] much better than [p] ?\n            var hidx = new Array(idx.length);\n            for(k=0;k<idx.length;k++){\n                hidx[k]=h[idx[k]];\n            }\n            var p_try = math.add(p, hidx);// update the [idx] elements\n\n            for(k=0;k<p_try.length;k++){\n                p_try[k][0]=Math.min(Math.max(p_min[k][0],p_try[k][0]),p_max[k][0]);\n            }\n            // p_try = Math.min(Math.max(p_min,p_try),p_max);           // apply constraints\n\n            var delta_y = math.subtract(y_dat, func(t,p_try,c));       // residual error using p_try\n            //func_calls = func_calls + 1;\n            //X2_try = delta_y' * ( delta_y .* weight_sq );  // Chi-squared error criteria\n\n            var X2_try = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n\n            if ( Update_Type == 2 ){  \t\t\t  // Quadratic\n                //    One step of quadratic line update in the h direction for minimum X2\n                //var alpha =  JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n                var JtWdy_th = math.multiply(math.transpose(JtWdy),h);\n                var alpha =  math.multiply(JtWdy_th,math.inv(math.add(math.multiply(math.subtract(X2_try - X2),1/2)),math.multiply(JtWdy_th,2)));//JtWdy'*h / ( (X2_try - X2)/2 + 2*JtWdy'*h ) ;\n\n                h = math.multiply(alpha, h);\n                for(var k=0;k<idx.length;k++){\n                    hidx[k]=h[idx[k]];\n                }\n\n                p_try = math.add(p ,hidx);                     // update only [idx] elements\n                p_try = math.min(math.max(p_min,p_try),p_max);          // apply constraints\n\n                delta_y = math.subtract(y_dat, func(t,p_try,c));      // residual error using p_try\n                // func_calls = func_calls + 1;\n                //X2_try = delta_y' * ( delta_y .* weight_sq ); // Chi-squared error criteria\n                X2_try = math.multiply(math.transpose(delta_y), mat.dotMultiply(delta_y, weight_sq));\n            }\n\n            //rho = (X2 - X2_try) / ( 2*h' * (lambda * h + JtWdy) ); // Nielsen\n            var rho = (X2-X2_try)/math.multiply(math.multiply(math.transpose(h),2),math.add(math.multiply(lambda, h),JtWdy));\n            //console.log(\"rho \"+rho);\n            if ( rho > epsilon_4 ) {\t\t// it IS significantly better\n                //console.log(\"Here\");\n                dX2 = X2 - X2_old;\n                X2_old = X2;\n                p_old = p;\n                y_old = y_hat;\n                p = p_try;\t\t\t// accept p_try\n\n                result = this.lm_matx(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c);\n                JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                // decrease lambda ==> Gauss-Newton method\n\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.max(lambda / lambda_DN_fac, 1.e-7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = Math.max(lambda / (1 + alpha), 1.e-7);\n                        break;\n                    case 3:\t\t\t\t\t\t\t// Nielsen\n                        lambda = math.multiply(Math.max(1 / 3, 1 - (2 * rho - 1) ^ 3),lambda);\n                        nu = 2;\n                        break;\n                }\n            }\n            else {\t\t\t\t\t// it IS NOT better\n                X2 = X2_old;\t\t\t// do not accept p_try\n                if (iteration%(2 * Npar)==0) {\t// rank-1 update of Jacobian\n                    result = this.lm_matx(func, t, p_old, y_old, -1, J, p, y_dat, weight_sq, dp, c);\n                    JtWJ = result.JtWJ,JtWdy=result.JtWdy,dX2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n                }\n\n                // increase lambda  ==> gradient descent method\n                switch (Update_Type) {\n                    case 1:\t\t\t\t\t\t\t// Levenberg\n                        lambda = Math.min(lambda * lambda_UP_fac, 1.e7);\n                        break;\n                    case 2:\t\t\t\t\t\t\t// Quadratic\n                        lambda = lambda + Math.abs((X2_try - X2) / 2 / alpha);\n                        break;\n                    case 3:\t\t\t\t\t\t// Nielsen\n                        lambda = lambda * nu;\n                        nu = 2 * nu;\n                        break;\n                }\n            }\n        }// --- End of Main Loop\n\n        // --- convergence achieved, find covariance and confidence intervals\n\n        // equal weights for paramter error analysis\n        weight_sq = math.multiply(math.multiply(math.transpose(delta_y),delta_y), Matrix.ones(Npnt,1));\n\n        weight_sq.apply(function(i,j){\n            weight_sq[i][j] = (Npnt-Nfit+1)/weight_sq[i][j];\n        });\n        //console.log(weight_sq);\n        result = this.lm_matx(func,t,p_old,y_old,-1,J,p,y_dat,weight_sq,dp,c);\n        JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;\n\n        /*if nargout > 2\t\t\t\t// standard error of parameters\n         covar = inv(JtWJ);\n         sigma_p = sqrt(diag(covar));\n         end\n\n         if nargout > 3\t\t\t\t// standard error of the fit\n         //  sigma_y = sqrt(diag(J * covar * J'));\t// slower version of below\n         sigma_y = zeros(Npnt,1);\n         for i=1:Npnt\n         sigma_y(i) = J(i,:) * covar * J(i,:)';\n         end\n         sigma_y = sqrt(sigma_y);\n         end\n\n         if nargout > 4\t\t\t\t// parameter correlation matrix\n         corr = covar ./ [sigma_p*sigma_p'];\n         end\n\n         if nargout > 5\t\t\t\t// coefficient of multiple determination\n         R_sq = corrcoef([y_dat y_hat]);\n         R_sq = R_sq(1,2).^2;\n         end\n\n         if nargout > 6\t\t\t\t// convergence history\n         cvg_hst = cvg_hst(1:iteration,:);\n         end*/\n\n        // endfunction  # ---------------------------------------------------------- LM\n\n        return { p:p, X2:X2};\n    },\n\n    lm_FD_J:function(func,t,p,y,dp,c) {\n        // J = lm_FD_J(func,t,p,y,{dp},{c})\n        //\n        // partial derivatives (Jacobian) dy/dp for use with lm.m\n        // computed via Finite Differences\n        // Requires n or 2n function evaluations, n = number of nonzero values of dp\n        // -------- INPUT VARIABLES ---------\n        // func = function of independent variables, 't', and parameters, 'p',\n        //        returning the simulated model: y_hat = func(t,p,c)\n        // t  = m-vector of independent variables (used as arg to func)\n        // p  = n-vector of current parameter values\n        // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J\n        // dp = fractional increment of p for numerical derivatives\n        //      dp(j)>0 central differences calculated\n        //      dp(j)<0 one sided differences calculated\n        //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //      Default:  0.001;\n        // c  = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n        var m = y.length;\t\t\t// number of data points\n        var n = p.length;\t\t\t// number of parameters\n\n        dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);\n\n        var ps = p.clone();//JSON.parse(JSON.stringify(p));\n        //var ps = $.extend(true, [], p);\n        var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero\n\n        for (var j = 0;j < n; j++) {\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n            del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation\n            p[j] = [ps[j][0]+del[j]];\t      // perturb parameter p(j)\n            //console.log(j+\" \"+dp[j]+\" \"+p[j]+\" \"+ps[j]+\" \"+del[j]);\n\n            if (del[j] != 0){\n                y1 = func(t, p, c);\n                //func_calls = func_calls + 1;\n                if (dp[j][0] < 0) {\t\t// backwards difference\n                    //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];\n                    //console.log(del[j]);\n                    //console.log(y);\n                    var column = math.dotDivide(math.subtract(y1, y),del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n                    //console.log(column);\n                }\n                else{\n                    p[j][0] = ps[j][0] - del[j];\n                    //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);\n                    var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);\n                    for(var k=0;k< m;k++){\n                        J[k][j]=column[k][0];\n                    }\n\n                }\t\t\t// central difference, additional func call\n            }\n\n            p[j] = ps[j];\t\t// restore p(j)\n\n        }\n        //console.log(\"lm_FD_J: \"+ JSON.stringify(J));\n        return J;\n\n    },\n\n    // endfunction # -------------------------------------------------- LM_FD_J\n    lm_Broyden_J: function(p_old,y_old,J,p,y){\n        // J = lm_Broyden_J(p_old,y_old,J,p,y)\n        // carry out a rank-1 update to the Jacobian matrix using Broyden's equation\n        //---------- INPUT VARIABLES -------\n        // p_old = previous set of parameters\n        // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)\n        // J  = current version of the Jacobian matrix\n        // p     = current  set of parameters\n        // y     = model evaluation at current  set of parameters, y_hat(t;p)\n        //---------- OUTPUT VARIABLES -------\n        // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)\ti=1:n; j=1:m\n        //console.log(p+\" X \"+ p_old)\n        var h  = math.subtract(p, p_old);\n\n        //console.log(\"hhh \"+h);\n        var h_t = math.transpose(h);\n        h_t.div(math.multiply(h_t,h));\n\n        //console.log(h_t);\n        //J = J + ( y - y_old - J*h )*h' / (h'*h);\t// Broyden rank-1 update eq'n\n        J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));\n        return J;\n        // endfunction # ---------------------------------------------- LM_Broyden_J\n    },\n\n    lm_matx : function (func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,dp,c,iteration){\n        // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})\n        //\n        // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,\n        // and calculate the Chi-squared error function, Chi_sq\n        // Used by Levenberg-Marquard algorithm, lm.m\n        // -------- INPUT VARIABLES ---------\n        // func   = function ofpn independent variables, p, and m parameters, p,\n        //         returning the simulated model: y_hat = func(t,p,c)\n        // t      = m-vectors or matrix of independent variables (used as arg to func)\n        // p_old  = n-vector of previous parameter values\n        // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);\n        // dX2    = previous change in Chi-squared criteria\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n        // p      = n-vector of current  parameter values\n        // y_dat  = n-vector of data to be fit by func(t,p,c)\n        // weight_sq = square of the weighting vector for least squares fit ...\n        //\t    inverse of the standard measurement errors\n        // dp     = fractional increment of 'p' for numerical derivatives\n        //          dp(j)>0 central differences calculated\n        //          dp(j)<0 one sided differences calculated\n        //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed\n        //          Default:  0.001;\n        // c      = optional vector of constants passed to y_hat = func(t,p,c)\n        //---------- OUTPUT VARIABLES -------\n        // JtWJ\t = linearized Hessian matrix (inverse of covariance matrix)\n        // JtWdy   = linearized fitting vector\n        // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR\n        // y_hat  = model evaluated with parameters 'p'\n        // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p\n\n        //   Henri Gavin, Dept. Civil & Environ. Engineering, Duke Univ. November 2005\n        //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/\n        //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.\n\n\n        var Npnt = y_dat.length;\t\t// number of data points\n        var Npar = p.length;\t\t// number of parameters\n\n        dp = dp || 0.001;\n\n\n        //var JtWJ = new Matrix.zeros(Npar);\n        //var JtWdy  = new Matrix.zeros(Npar,1);\n\n        var y_hat = func(t,p,c);\t// evaluate model using parameters 'p'\n        //func_calls = func_calls + 1;\n        //console.log(J);\n        if ( (iteration%(2*Npar))==0 || dX2 > 0 ) {\n            //console.log(\"Par\");\n            J = this.lm_FD_J(func, t, p, y_hat, dp, c);\t\t// finite difference\n        }\n        else{\n            //console.log(\"ImPar\");\n            J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update\n        }\n        var delta_y = math.subtract(y_dat, y_hat);\t// residual error between model and data\n        //console.log(delta_y[0][0]);\n        //console.log(delta_y.rows+\" \"+delta_y.columns+\" \"+JSON.stringify(weight_sq));\n        //var Chi_sq = delta_y' * ( delta_y .* weight_sq ); \t// Chi-squared error criteria\n        var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));\n        //JtWJ  = J' * ( J .* ( weight_sq * ones(1,Npar) ) );\n        var Jt = math.transpose(J);\n\n        //console.log(weight_sq);\n\n        var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));\n\n        //JtWdy = J' * ( weight_sq .* delta_y );\n        var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));\n\n\n        return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};\n        // endfunction  # ------------------------------------------------------ LM_MATX\n    }\n\n\n\n};\n\nmodule.exports = LM;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-curve-fitting/src/LM.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nmodule.exports = require('./matrix');\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/index.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nvar Asplice = Array.prototype.splice,\n    Aconcat = Array.prototype.concat;\n\n// For performance : http://jsperf.com/clone-array-slice-vs-while-vs-for\nfunction slice(arr) {\n    var i = 0,\n        ii = arr.length,\n        result = new Array(ii);\n    for (; i < ii; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\n\n/**\n * Real matrix.\n * @constructor\n * @param {number|Array} nRows - Number of rows of the new matrix or a 2D array containing the data.\n * @param {number|boolean} [nColumns] - Number of columns of the new matrix or a boolean specifying if the input array should be cloned\n */\nfunction Matrix(nRows, nColumns) {\n    var i = 0, rows, columns, matrix, newInstance;\n    if (Array.isArray(nRows)) {\n        newInstance = nColumns;\n        matrix = newInstance ? slice(nRows) : nRows;\n        nRows = matrix.length;\n        nColumns = matrix[0].length;\n        if (typeof nColumns === 'undefined') {\n            throw new TypeError('Data must be a 2D array');\n        }\n        if (nRows > 0 && nColumns > 0) {\n            for (; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                } else if (newInstance) {\n                    matrix[i] = slice(matrix[i]);\n                }\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else if (typeof nRows === 'number') { // Create empty matrix\n        if (nRows > 0 && nColumns > 0) {\n            matrix = new Array(nRows);\n            for (; i < nRows; i++) {\n                matrix[i] = new Array(nColumns);\n            }\n        } else {\n            throw new RangeError('Invalid dimensions: ' + nRows + 'x' + nColumns);\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n\n    Object.defineProperty(matrix, 'rows', {writable: true, value: nRows});\n    Object.defineProperty(matrix, 'columns', {writable: true, value: nColumns});\n\n    matrix.__proto__ = Matrix.prototype;\n\n    return matrix;\n}\n\n/**\n * Constructs a Matrix with the chosen dimensions from a 1D array.\n * @param {number} newRows - Number of rows\n * @param {number} newColumns - Number of columns\n * @param {Array} newData - A 1D array containing data for the matrix\n * @returns {Matrix} - The new matrix\n */\nMatrix.from1DArray = function from1DArray(newRows, newColumns, newData) {\n    var length, data, i = 0;\n\n    length = newRows * newColumns;\n    if (length !== newData.length)\n        throw new RangeError('Data length does not match given dimensions');\n\n    data = new Array(newRows);\n    for (; i < newRows; i++) {\n        data[i] = newData.slice(i * newColumns, (i + 1) * newColumns);\n    }\n    return new Matrix(data);\n};\n\n/**\n * Creates a row vector, a matrix with only one row.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.rowVector = function rowVector(newData) {\n    return new Matrix([newData]);\n};\n\n/**\n * Creates a column vector, a matrix with only one column.\n * @param {Array} newData - A 1D array containing data for the vector\n * @returns {Matrix} - The new matrix\n */\nMatrix.columnVector = function columnVector(newData) {\n    var l = newData.length, vector = new Array(l);\n    for (var i = 0; i < l; i++)\n        vector[i] = [newData[i]];\n    return new Matrix(vector);\n};\n\n/**\n * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.empty = function empty(rows, columns) {\n    return new Matrix(rows, columns);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to zero.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.zeros = function zeros(rows, columns) {\n    return Matrix.empty(rows, columns).fill(0);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be set to one.\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.ones = function ones(rows, columns) {\n    return Matrix.empty(rows, columns).fill(1);\n};\n\n/**\n * Creates a matrix with the given dimensions. Values will be randomly set using Math.random().\n * @param {number} rows - Number of rows\n * @param {number} columns - Number of columns\n * @returns {Matrix} The new matrix\n */\nMatrix.rand = function rand(rows, columns) {\n    var matrix = Matrix.empty(rows, columns);\n    for (var i = 0, ii = matrix.rows; i < ii; i++) {\n        for (var j = 0, jj = matrix.columns; j < jj; j++) {\n            matrix[i][j] = Math.random();\n        }\n    }\n    return matrix;\n};\n\n/**\n * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and other will be 0.\n * @param {number} n - Number of rows and columns\n * @returns {Matrix} - The new matrix\n */\nMatrix.eye = function eye(n) {\n    var matrix = Matrix.zeros(n, n), l = matrix.rows;\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = 1;\n    }\n    return matrix;\n};\n\n/**\n * Creates a diagonal matrix based on the given array.\n * @param {Array} data - Array containing the data for the diagonal\n * @returns {Matrix} - The new matrix\n */\nMatrix.diag = function diag(data) {\n    var l = data.length, matrix = Matrix.zeros(l, l);\n    for (var i = 0; i < l; i++) {\n        matrix[i][i] = data[i];\n    }\n    return matrix;\n};\n\n/**\n * Creates an array of indices between two values\n * @param {number} from\n * @param {number} to\n * @returns {Array}\n */\nMatrix.indices = function indices(from, to) {\n    var vector = new Array(to - from);\n    for (var i = 0; i < vector.length; i++)\n        vector[i] = from++;\n    return vector;\n};\n\n// TODO DOC\nMatrix.stack = function stack(arg1) {\n    var i, j, k;\n    if (Matrix.isMatrix(arg1)) {\n        var rows = 0,\n            cols = 0;\n        for (i = 0; i < arguments.length; i++) {\n            rows += arguments[i].rows;\n            if (arguments[i].columns > cols)\n                cols = arguments[i].columns;\n        }\n\n        var r = Matrix.zeros(rows, cols);\n        var c = 0;\n        for (i = 0; i < arguments.length; i++) {\n            var current = arguments[i];\n            for (j = 0; j < current.rows; j++) {\n                for (k = 0; k < current.columns; k++)\n                    r[c][k] = current[j][k];\n                c++;\n            }\n        }\n        return r;\n    }\n    else if (Array.isArray(arg1)) {\n        var matrix = Matrix.empty(arguments.length, arg1.length);\n        for (i = 0; i < arguments.length; i++)\n            matrix.setRow(i, arguments[i]);\n        return matrix;\n    }\n};\n\n// TODO DOC\nMatrix.expand = function expand(base, count) {\n    var expansion = [];\n    for (var i = 0; i < count.length; i++)\n        for (var j = 0; j < count[i]; j++)\n            expansion.push(base[i]);\n    return new Matrix(expansion);\n};\n\n/**\n * Check that the provided value is a Matrix and tries to instantiate one if not\n * @param value - The value to check\n * @returns {Matrix}\n * @throws {TypeError}\n */\nMatrix.checkMatrix = function checkMatrix(value) {\n    if (!value) {\n        throw new TypeError('Argument has to be a matrix');\n    }\n    if (value.klass !== 'Matrix') {\n        value = new Matrix(value);\n    }\n    return value;\n};\n\n/**\n * Returns true if the argument is a Matrix, false otherwise\n * @param value - The value to check\n * @returns {boolean}\n */\nMatrix.isMatrix = function isMatrix(value) {\n    return value ? value.klass === 'Matrix' : false;\n};\n\n/**\n * @property {string} - The name of this class.\n */\nObject.defineProperty(Matrix.prototype, 'klass', {\n    get: function klass() {\n        return 'Matrix';\n    }\n});\n\n/**\n * @property {number} - The number of elements in the matrix.\n */\nObject.defineProperty(Matrix.prototype, 'size', {\n    get: function size() {\n        return this.rows * this.columns;\n    }\n});\n\n/**\n * @private\n * Internal check that a row index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkRowIndex = function checkRowIndex(index) {\n    if (index < 0 || index > this.rows - 1)\n        throw new RangeError('Row index out of range.');\n};\n\n/**\n * @private\n * Internal check that a column index is not out of bounds\n * @param {number} index\n */\nMatrix.prototype.checkColumnIndex = function checkColumnIndex(index) {\n    if (index < 0 || index > this.columns - 1)\n        throw new RangeError('Column index out of range.');\n};\n\n/**\n * @private\n * Internal check that two matrices have the same dimensions\n * @param {Matrix} otherMatrix\n */\nMatrix.prototype.checkDimensions = function checkDimensions(otherMatrix) {\n    if ((this.rows !== otherMatrix.rows) || (this.columns !== otherMatrix.columns))\n        throw new RangeError('Matrices dimensions must be equal.');\n};\n\n/**\n * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n * @returns {Matrix} this\n */\nMatrix.prototype.apply = function apply(callback) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            callback.call(this, i, j);\n        }\n    }\n    return this;\n};\n\n/**\n * Creates an exact and independent copy of the matrix\n * @returns {Matrix}\n */\nMatrix.prototype.clone = function clone() {\n    return new Matrix(this.to2DArray());\n};\n\n/**\n * Returns a new 1D array filled row by row with the matrix values\n * @returns {Array}\n */\nMatrix.prototype.to1DArray = function to1DArray() {\n    return Aconcat.apply([], this);\n};\n\n/**\n * Returns a 2D array containing a copy of the data\n * @returns {Array}\n */\nMatrix.prototype.to2DArray = function to2DArray() {\n    var l = this.rows, copy = new Array(l);\n    for (var i = 0; i < l; i++) {\n        copy[i] = slice(this[i]);\n    }\n    return copy;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row\n */\nMatrix.prototype.isRowVector = function isRowVector() {\n    return this.rows === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one column\n */\nMatrix.prototype.isColumnVector = function isColumnVector() {\n    return this.columns === 1;\n};\n\n/**\n * @returns {boolean} true if the matrix has one row or one column\n */\nMatrix.prototype.isVector = function isVector() {\n    return (this.rows === 1) || (this.columns === 1);\n};\n\n/**\n * @returns {boolean} true if the matrix has the same number of rows and columns\n */\nMatrix.prototype.isSquare = function isSquare() {\n    return this.rows === this.columns;\n};\n\n/**\n * @returns {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n */\nMatrix.prototype.isSymmetric = function isSymmetric() {\n    if (this.isSquare()) {\n        var l = this.rows;\n        for (var i = 0; i < l; i++) {\n            for (var j = 0; j <= i; j++) {\n                if (this[i][j] !== this[j][i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @param {number} value - The new value for the element\n * @returns {Matrix} this\n */\nMatrix.prototype.set = function set(rowIndex, columnIndex, value) {\n    this[rowIndex][columnIndex] = value;\n    return this;\n};\n\n/**\n * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n * @param {number} rowIndex - Index of the row\n * @param {number} columnIndex - Index of the column\n * @returns {number}\n */\nMatrix.prototype.get = function get(rowIndex, columnIndex) {\n    return this[rowIndex][columnIndex];\n};\n\n/**\n * Fills the matrix with a given value. All elements will be set to this value.\n * @param {number} value - New value\n * @returns {Matrix} this\n */\nMatrix.prototype.fill = function fill(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = value;\n        }\n    }\n    return this;\n};\n\n/**\n * Negates the matrix. All elements will be multiplied by (-1)\n * @returns {Matrix} this\n */\nMatrix.prototype.neg = function neg() {\n    return this.mulS(-1);\n};\n\n/**\n * Adds a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number')\n        return this.addS(value);\n    value = Matrix.checkMatrix(value);\n        return this.addM(value);\n};\n\n/**\n * Adds a scalar to each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.addS = function addS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += value;\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the value of each element of matrix to the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.addM = function addM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number')\n        return this.subS(value);\n    value = Matrix.checkMatrix(value);\n        return this.subM(value);\n};\n\n/**\n * Subtracts a scalar from each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.subS = function subS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the value of each element of matrix from the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.subM = function subM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number')\n        return this.mulS(value);\n    value = Matrix.checkMatrix(value);\n        return this.mulM(value);\n};\n\n/**\n * Multiplies a scalar with each element of the matrix\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulS = function mulS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the value of each element of matrix with the corresponding element of this\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.mulM = function mulM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides by a scalar or values from another matrix (in place)\n * @param {number|Matrix} value\n * @returns {Matrix} this\n */\nMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number')\n        return this.divS(value);\n    value = Matrix.checkMatrix(value);\n        return this.divM(value);\n};\n\n/**\n * Divides each element of the matrix by a scalar\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.divS = function divS(value) {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= value;\n        }\n    }\n    return this;\n};\n\n/**\n * Divides each element of this by the corresponding element of matrix\n * @param {Matrix} matrix\n * @returns {Matrix} this\n */\nMatrix.prototype.divM = function divM(matrix) {\n    this.checkDimensions(matrix);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= matrix[i][j];\n        }\n    }\n    return this;\n};\n\n/**\n * Returns a new array from the given row index\n * @param {number} index - Row index\n * @returns {Array}\n */\nMatrix.prototype.getRow = function getRow(index) {\n    this.checkRowIndex(index);\n    return slice(this[index]);\n};\n\n/**\n * Returns a new row vector from the given row index\n * @param {number} index - Row index\n * @returns {Matrix}\n */\nMatrix.prototype.getRowVector = function getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n};\n\n/**\n * Sets a row at the given index\n * @param {number} index - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setRow = function setRow(index, array) {\n    this.checkRowIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    this[index] = slice(array);\n    return this;\n};\n\n/**\n * Removes a row from the given index\n * @param {number} index - Row index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeRow = function removeRow(index) {\n    this.checkRowIndex(index);\n    if (this.rows === 1)\n        throw new RangeError('A matrix cannot have less than one row');\n    Asplice.call(this, index, 1);\n    this.rows -= 1;\n    return this;\n};\n\n/**\n * Adds a row at the given index\n * @param {number} [index = this.rows] - Row index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRow = function addRow(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.rows;\n    }\n    if (index < 0 || index > this.rows)\n        throw new RangeError('Row index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    if (array.length !== this.columns)\n        throw new RangeError('Invalid row size');\n    Asplice.call(this, index, 0, slice(array));\n    this.rows += 1;\n    return this;\n};\n\n/**\n * Swaps two rows\n * @param {number} row1 - First row index\n * @param {number} row2 - Second row index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapRows = function swapRows(row1, row2) {\n    this.checkRowIndex(row1);\n    this.checkRowIndex(row2);\n    var temp = this[row1];\n    this[row1] = this[row2];\n    this[row2] = temp;\n    return this;\n};\n\n/**\n * Returns a new array from the given column index\n * @param {number} index - Column index\n * @returns {Array}\n */\nMatrix.prototype.getColumn = function getColumn(index) {\n    this.checkColumnIndex(index);\n    var l = this.rows, column = new Array(l);\n    for (var i = 0; i < l; i++) {\n        column[i] = this[i][index];\n    }\n    return column;\n};\n\n/**\n * Returns a new column vector from the given column index\n * @param {number} index - Column index\n * @returns {Matrix}\n */\nMatrix.prototype.getColumnVector = function getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n};\n\n/**\n * Sets a column at the given index\n * @param {number} index - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.setColumn = function setColumn(index, array) {\n    this.checkColumnIndex(index);\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i][index] = array[i];\n    }\n    return this;\n};\n\n/**\n * Removes a column from the given index\n * @param {number} index - Column index\n * @returns {Matrix} this\n */\nMatrix.prototype.removeColumn = function removeColumn(index) {\n    this.checkColumnIndex(index);\n    if (this.columns === 1)\n        throw new RangeError('A matrix cannot have less than one column');\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].splice(index, 1);\n    }\n    this.columns -= 1;\n    return this;\n};\n\n/**\n * Adds a column at the given index\n * @param {number} [index = this.columns] - Column index\n * @param {Array|Matrix} array - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumn = function addColumn(index, array) {\n    if (typeof array === 'undefined') {\n        array = index;\n        index = this.columns;\n    }\n    if (index < 0 || index > this.columns)\n        throw new RangeError('Column index out of range.');\n    if (Matrix.isMatrix(array)) array = array.to1DArray();\n    var l = this.rows;\n    if (array.length !== l)\n        throw new RangeError('Invalid column size');\n    for (var i = 0; i < l; i++) {\n        this[i].splice(index, 0, array[i]);\n    }\n    this.columns += 1;\n    return this;\n};\n\n/**\n * Swaps two columns\n * @param {number} column1 - First column index\n * @param {number} column2 - Second column index\n * @returns {Matrix} this\n */\nMatrix.prototype.swapColumns = function swapColumns(column1, column2) {\n    this.checkRowIndex(column1);\n    this.checkRowIndex(column2);\n    var l = this.rows, temp, row;\n    for (var i = 0; i < l; i++) {\n        row = this[i];\n        temp = row[column1];\n        row[column1] = row[column2];\n        row[column2] = temp;\n    }\n    return this;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkRowVector = function checkRowVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.columns)\n        throw new RangeError('vector size must be the same as the number of columns');\n    return vector;\n};\n\n/**\n * @private\n * Internal check that the provided vector is an array with the right length\n * @param {Array|Matrix} vector\n * @returns {Array}\n * @throws {RangeError}\n */\nMatrix.prototype.checkColumnVector = function checkColumnVector(vector) {\n    if (Matrix.isMatrix(vector))\n        vector = vector.to1DArray();\n    if (vector.length !== this.rows)\n        throw new RangeError('vector size must be the same as the number of rows');\n    return vector;\n};\n\n/**\n * Adds the values of a vector to each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addRowVector = function addRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subRowVector = function subRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each row\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRowVector = function mulRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each row by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divRowVector = function divRowVector(vector) {\n    vector = this.checkRowVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[j];\n        }\n    }\n    return this;\n};\n\n/**\n * Adds the values of a vector to each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.addColumnVector = function addColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] += vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Subtracts the values of a vector from each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.subColumnVector = function subColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] -= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a vector with each column\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumnVector = function mulColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] *= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Divides the values of each column by those of a vector\n * @param {Array|Matrix} vector - Array or vector\n * @returns {Matrix} this\n */\nMatrix.prototype.divColumnVector = function divColumnVector(vector) {\n    vector = this.checkColumnVector(vector);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] /= vector[i];\n        }\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a row with a scalar\n * @param {number} index - Row index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulRow = function mulRow(index, value) {\n    this.checkRowIndex(index);\n    var i = 0, l = this.columns;\n    for (; i < l; i++) {\n        this[index][i] *= value;\n    }\n    return this;\n};\n\n/**\n * Multiplies the values of a column with a scalar\n * @param {number} index - Column index\n * @param {number} value\n * @returns {Matrix} this\n */\nMatrix.prototype.mulColumn = function mulColumn(index, value) {\n    this.checkColumnIndex(index);\n    var i = 0, l = this.rows;\n    for (; i < l; i++) {\n        this[i][index] *= value;\n    }\n};\n\n/**\n * A matrix index\n * @typedef {Object} MatrixIndex\n * @property {number} row\n * @property {number} column\n */\n\n/**\n * Returns the maximum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.max = function max() {\n    var v = -Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxIndex = function maxIndex() {\n    var v = -Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] > v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of the matrix\n * @returns {number}\n */\nMatrix.prototype.min = function min() {\n    var v = Infinity;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n            }\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minIndex = function minIndex() {\n    var v = Infinity;\n    var idx = {};\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (this[i][j] < v) {\n                v = this[i][j];\n                idx.row = i;\n                idx.column = j;\n            }\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.maxRow = function maxRow(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxRowIndex = function maxRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = -Infinity;\n    var idx = {\n            row: index\n        };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] > v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one row\n * @param {number} index - Row index\n * @returns {number}\n */\nMatrix.prototype.minRow = function minRow(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one row\n * @param {number} index - Row index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minRowIndex = function minRowIndex(index) {\n    this.checkRowIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: index,\n        column: 0\n    };\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        if (this[index][i] < v) {\n            v = this[index][i];\n            idx.column = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the maximum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.maxColumn = function maxColumn(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the maximum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.maxColumnIndex = function maxColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = -Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] > v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns the minimum value of one column\n * @param {number} index - Column index\n * @returns {number}\n */\nMatrix.prototype.minColumn = function minColumn(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the index of the minimum value of one column\n * @param {number} index - Column index\n * @returns {MatrixIndex}\n */\nMatrix.prototype.minColumnIndex = function minColumnIndex(index) {\n    this.checkColumnIndex(index);\n    var v = Infinity;\n    var idx = {\n        row: 0,\n        column: index\n    };\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        if (this[i][index] < v) {\n            v = this[i][index];\n            idx.row = i;\n        }\n    }\n    return idx;\n};\n\n/**\n * Returns an array containing the diagonal values of the matrix\n * @returns {Array}\n */\nMatrix.prototype.diag = function diag() {\n    if (!this.isSquare())\n        throw new TypeError('Only square matrices have a diagonal.');\n    var diag = new Array(this.rows);\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        diag[i] = this[i][i];\n    }\n    return diag;\n};\n\n/**\n * Returns the sum of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.sum = function sum() {\n    var v = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            v += this[i][j];\n        }\n    }\n    return v;\n};\n\n/**\n * Returns the mean of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.mean = function mean() {\n    return this.sum() / this.size;\n};\n\n/**\n * Returns the product of all elements of the matrix\n * @returns {number}\n */\nMatrix.prototype.prod = function prod() {\n    var prod = 1;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            prod *= this[i][j];\n        }\n    }\n    return prod;\n};\n\n/**\n * Computes the cumulative sum of the matrix elements (in place, row by row)\n * @returns {Matrix} this\n */\nMatrix.prototype.cumulativeSum = function cumulativeSum() {\n    var sum = 0;\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            sum += this[i][j];\n            this[i][j] = sum;\n        }\n    }\n    return this;\n};\n\n/**\n * Computes the dot (scalar) product between the matrix and another\n * @param {Matrix} other vector\n * @returns {number}\n */\nMatrix.prototype.dot = function dot(other) {\n    if (this.size !== other.size)\n        throw new RangeError('vectors do not have the same size');\n    var vector1 = this.to1DArray();\n    var vector2 = other.to1DArray();\n    var dot = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        dot += vector1[i] * vector2[i];\n    }\n    return dot;\n};\n\n/**\n * Returns the matrix product between this and other\n * @returns {Matrix}\n */\nMatrix.prototype.mmul = function mmul(other) {\n    if (!Matrix.isMatrix(other))\n        throw new TypeError('parameter \"other\" must be a matrix');\n    if (this.columns !== other.rows)\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n\n    var m = this.rows, n = this.columns, p = other.columns;\n    var result = new Matrix(m, p);\n\n    var Bcolj = new Array(n);\n    var i, j, k;\n    for (j = 0; j < p; j++) {\n        for (k = 0; k < n; k++)\n            Bcolj[k] = other[k][j];\n\n        for (i = 0; i < m; i++) {\n            var Arowi = this[i];\n\n            var s = 0;\n            for (k = 0; k < n; k++)\n                s += Arowi[k] * Bcolj[k];\n\n            result[i][j] = s;\n        }\n    }\n    return result;\n};\n\n/**\n * Sorts the rows (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortRows = function sortRows(compareFunction) {\n    for (var i = 0, ii = this.rows; i < ii; i++) {\n        this[i].sort(compareFunction);\n    }\n    return this;\n};\n\n/**\n * Sorts the columns (in place)\n * @param {function} compareFunction - usual Array.prototype.sort comparison function\n * @returns {Matrix} this\n */\nMatrix.prototype.sortColumns = function sortColumns(compareFunction) {\n    for (var i = 0, ii = this.columns; i < ii; i++) {\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n};\n\n/**\n * Transposes the matrix and returns a new one containing the result\n * @returns {Matrix}\n */\nMatrix.prototype.transpose = function transpose() {\n    var result = new Matrix(this.columns, this.rows);\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[j][i] = this[i][j];\n        }\n    }\n    return result;\n};\n\n/**\n * Returns a subset of the matrix\n * @param {number} startRow - First row index\n * @param {number} endRow - Last row index\n * @param {number} startColumn - First column index\n * @param {number} endColumn - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrix = function subMatrix(startRow, endRow, startColumn, endColumn) {\n    if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range');\n    var newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);\n    for (var i = startRow; i <= endRow; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            newMatrix[i - startRow][j - startColumn] = this[i][j];\n        }\n    }\n    return newMatrix;\n};\n\n/**\n * Returns a subset of the matrix based on an array of row indices\n * @param {Array} indices - Array containing the row indices\n * @param {number} [startColumn = 0] - First column index\n * @param {number} [endColumn = this.columns-1] - Last column index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixRow = function subMatrixRow(indices, startColumn, endColumn) {\n    if (typeof startColumn === 'undefined') {\n        startColumn = 0;\n        endColumn = this.columns - 1;\n    } else if (typeof endColumn === 'undefined') {\n        endColumn = this.columns - 1;\n    }\n    if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, rows = this.rows,\n        X = new Matrix(l, endColumn - startColumn + 1);\n    for (var i = 0; i < l; i++) {\n        for (var j = startColumn; j <= endColumn; j++) {\n            if ((indices[i] < 0) || (indices[i] >= rows))\n                throw new RangeError('Argument out of range.');\n            X[i][j - startColumn] = this[indices[i]][j];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns a subset of the matrix based on an array of column indices\n * @param {Array} indices - Array containing the column indices\n * @param {number} [startRow = 0] - First row index\n * @param {number} [endRow = this.rows-1] - Last row index\n * @returns {Matrix}\n */\nMatrix.prototype.subMatrixColumn = function subMatrixColumn(indices, startRow, endRow) {\n    if (typeof startRow === 'undefined') {\n        startRow = 0;\n        endRow = this.rows - 1;\n    } else if (typeof endRow === 'undefined') {\n        endRow = this.rows - 1;\n    }\n    if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows))\n        throw new RangeError('Argument out of range.');\n    var l = indices.length, columns = this.columns,\n        X = new Matrix(endRow - startRow + 1, l);\n    for (var i = 0; i < l; i++) {\n        for (var j = startRow; j <= endRow; j++) {\n            if ((indices[i] < 0) || (indices[i] >= columns))\n                throw new RangeError('Argument out of range.');\n            X[j - startRow][i] = this[j][indices[i]];\n        }\n    }\n    return X;\n};\n\n/**\n * Returns the trace of the matrix (sum of the diagonal elements)\n * @returns {number}\n */\nMatrix.prototype.trace = function trace() {\n    if (!this.isSquare())\n        throw new TypeError('The matrix is not square');\n    var trace = 0, i = 0, l = this.rows;\n    for (; i < l; i++) {\n        trace += this[i][i];\n    }\n    return trace;\n};\n\n/**\n * Sets each element of the matrix to its absolute value\n * @returns {Matrix} this\n */\nMatrix.prototype.abs = function abs() {\n    var ii = this.rows, jj = this.columns;\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            this[i][j] = Math.abs(this[i][j]);\n        }\n    }\n};\n\nmodule.exports = Matrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/matrix.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nvar Matrix = require('./matrix');\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\nMatrix.prototype.inverse = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/decompositions.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var a = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false)\n        wantu = false;\n    if (options.computeRightSingularVectors === false)\n        wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    if (m < n) {\n        if (!autoTranspose) {\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = a.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = Matrix.zeros(m, nu),\n        V = Matrix.zeros(n, n),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0)\n                    e[k] = -e[k];\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        return this.U;\n    },\n    get rightSingularVectors() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n\n        var VL = this.V.mmul(Ls),\n            vrows = this.V.rows,\n            urows = this.U.rows,\n            VLU = Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * this.U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.diag(value));\n    },\n    inverse: function () {\n        var e = this.threshold,\n            vrows = this.V.rows,\n            vcols = this.V.columns,\n            X = new Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = this.V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var urows = this.U.rows,\n            ucols = this.U.columns,\n            Y = new Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * this.U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/svd.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/util.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix) {\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = Matrix.zeros(n, n),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    if (matrix.isSymmetric()) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value[i][j];\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    }\n    else {\n        var H = Matrix.zeros(n, n),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value[i][j];\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            }\n            else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    }\n    else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/evd.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare())\n            throw new Error('Matrix must be square');\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++)\n            determinant *= data[j][j];\n        return determinant;\n    },\n    get lowerTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularFactor() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows)\n            throw new Error('Invalid matrix dimensions');\n        if (this.isSingular())\n            throw new Error('LU matrix is singular');\n\n        var count = value.columns,\n            X = value.subMatrixRow(this.pivotVector, 0, count - 1),\n            columns = lu.columns,\n            i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/lu.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m)\n            throw new Error('Matrix row dimensions must agree');\n        if (!this.isFullRank())\n            throw new Error('Matrix is rank deficient');\n\n        var count = value.columns,\n            X = value.clone(),\n            n = qr.columns,\n            i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularFactor() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalFactor() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/qr.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric())\n        throw new Error('Matrix is not symmetric');\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get leftTriangularFactor() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/cholesky.js\n// module id = 13\n// module chunks = 0","/**\n * Created by acastillo on 8/24/15.\n */\n/**\n * Non in-place function definitions, compatible with mathjs code *\n */\n\n'use strict';\n\nvar Matrix = require('ml-matrix');\n\nfunction matrix(A,B){\n    return new Matrix(A,B);\n}\n\nfunction ones(rows, cols){\n    return Matrix.ones(rows,cols);\n}\n\nfunction eye(rows, cols){\n    return Matrix.eye(rows, cols);\n}\n\nfunction zeros(rows, cols){\n    return Matrix.zeros(rows, cols);\n}\n\nfunction random(rows, cols){\n    return Matrix.rand(rows,cols);\n}\n\nfunction transpose(A){\n    if(typeof A == 'number')\n        return A;\n    var result = A.clone();\n    return result.transpose();\n}\n\nfunction add(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A+B;\n    if(typeof A == 'number')\n        return this.add(B,A);\n\n    var result = A.clone();\n    return result.add(B);\n\n}\n\nfunction subtract(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A-B;\n    if(typeof A == 'number')\n        return this.subtract(B,A);\n    var result = A.clone();\n    return result.sub(B);\n}\n\nfunction multiply(A, B){\n    if(typeof A == 'number'&&typeof B === 'number')\n        return A*B;\n    if(typeof A == 'number')\n        return this.multiply(B,A);\n\n    var result = A.clone();\n\n    if(typeof B === 'number')\n        result.mul(B);\n    else\n        result = result.mmul(B);\n\n    if(result.rows==1&&result.columns==1)\n        return result[0][0];\n    else\n        return result;\n\n}\n\nfunction dotMultiply(A, B){\n    var result = A.clone();\n    return result.mul(B);\n}\n\nfunction dotDivide(A, B){\n    var result = A.clone();\n    return result.div(B);\n}\n\nfunction diag(A){\n    var diag = null;\n    var rows = A.rows, cols = A.columns, j, r;\n    //It is an array\n    if(typeof cols === \"undefined\" && (typeof A)=='object'){\n        if(A[0]&&A[0].length){\n            rows = A.length;\n            cols = A[0].length;\n            r = Math.min(rows,cols);\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j][j];\n            }\n        }\n        else{\n            cols = A.length;\n            diag = Matrix.zeros(cols, cols);\n            for (j = 0; j < cols; j++) {\n                diag[j][j]=A[j];\n            }\n        }\n\n    }\n    if(rows == 1){\n        diag = Matrix.zeros(cols, cols);\n        for (j = 0; j < cols; j++) {\n            diag[j][j]=A[0][j];\n        }\n    }\n    else{\n        if(rows>0 && cols > 0){\n            r = Math.min(rows,cols);\n            diag = new Array(r);\n            for (j = 0; j < r; j++) {\n                diag[j] = A[j][j];\n            }\n        }\n    }\n    return diag;\n}\n\nfunction min(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.min(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] < B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction max(A, B){\n    if(typeof A==='number' && typeof B ==='number')\n        return Math.max(A,B);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            if (A[i][j] > B[i][j]) {\n                result[i][j] = A[i][j];\n            }\n            else{\n                result[i][j] = B[i][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction sqrt(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.sqrt(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction abs(A){\n    if(typeof A==='number' )\n        return Math.abs(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.abs(A[i][j]);\n\n        }\n    }\n    return result;\n}\n\nfunction exp(A){\n    if(typeof A==='number' )\n        return Math.sqrt(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.exp(A[i][j]);\n        }\n    }\n    return result;\n}\n\nfunction dotPow(A, b){\n    if(typeof A==='number' )\n        return Math.pow(A,b);\n    //console.log(A);\n    var ii = A.rows, jj = A.columns;\n    var result = new Matrix(ii,jj);\n    for (var i = 0; i < ii; i++) {\n        for (var j = 0; j < jj; j++) {\n            result[i][j] = Math.pow(A[i][j],b);\n        }\n    }\n    return result;\n}\n\nfunction solve(A, B){\n    return A.solve(B);\n}\n\nfunction inv(A){\n    if(typeof A ===\"number\")\n        return 1/A;\n    return A.inverse();\n}\n\nmodule.exports = {\n    transpose:transpose,\n    add:add,\n    subtract:subtract,\n    multiply:multiply,\n    dotMultiply:dotMultiply,\n    dotDivide:dotDivide,\n    diag:diag,\n    min:min,\n    max:max,\n    solve:solve,\n    inv:inv,\n    sqrt:sqrt,\n    exp:exp,\n    dotPow:dotPow,\n    abs:abs,\n    matrix:matrix,\n    ones:ones,\n    zeros:zeros,\n    random:random,\n    eye:eye\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-curve-fitting/src/algebra.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nconst extend = require('extend');\nconst SG = require('ml-savitzky-golay-generalized');\n\nconst defaultOptions = {\n    sgOptions: {\n        windowSize: 9,\n        polynomial: 3\n    },\n    minMaxRatio: 0.00025,\n    broadRatio: 0.00,\n    maxCriteria: true,\n    smoothY: true,\n    realTopDetection: false,\n    heightFactor: 0,\n    boundaries: false,\n    derivativeThreshold: -1\n};\n\n/**\n * Global spectra deconvolution\n * @param {Array<Number>} x - Independent variable\n * @param {Array<Number>} yIn - Dependent variable\n * @param {Object} [options] - Options object\n * @param {Object} [options.sgOptions] - Options object for Savitzky-Golay filter. See https://github.com/mljs/savitzky-golay-generalized#options\n * @param {Number} [options.sgOptions.windowSize = 9] - points to use in the approximations\n * @param {Number} [options.sgOptions.polynomial = 3] - degree of the polynomial to use in the approximations\n * @param {Number} [options.minMaxRatio = 0.00025] - Threshold to determine if a given peak should be considered as a noise\n * @param {Number} [options.broadRatio = 0.00] - If `broadRatio` is higher than 0, then all the peaks which second derivative\n * smaller than `broadRatio * maxAbsSecondDerivative` will be marked with the soft mask equal to true.\n * @param {Number} [options.noiseLevel = 0] - Noise threshold in spectrum units\n * @param {Boolean} [options.maxCriteria = true] - Peaks are local maximum(true) or minimum(false)\n * @param {Boolean} [options.smoothY = true] - Select the peak intensities from a smoothed version of the independent variables\n * @param {Boolean} [options.realTopDetection = false] - Use a quadratic optimizations with the peak and its 3 closest neighbors\n * to determine the true x,y values of the peak?\n * @param {Number} [options.heightFactor = 0] - Factor to multiply the calculated height (usually 2)\n * @param {Boolean} [options.boundaries = false] - Return also the inflection points of the peaks\n * @param {Number} [options.derivativeThreshold = -1] - Filters based on the amplitude of the first derivative\n * @return {Array<Object>}\n */\nfunction gsd(x, yIn, options) {\n    options = extend({}, defaultOptions, options);\n    let sgOptions = options.sgOptions;\n    const y = [].concat(yIn);\n\n    if (!('noiseLevel' in options)) {\n        // We have to know if x is equally spaced\n        var maxDx = 0,\n            minDx = Number.MAX_VALUE,\n            tmp;\n        for (let i = 0; i < x.length - 1; ++i) {\n            tmp = Math.abs(x[i + 1] - x[i]);\n            if (tmp < minDx) {\n                minDx = tmp;\n            }\n            if (tmp > maxDx) {\n                maxDx = tmp;\n            }\n        }\n\n        if ((maxDx - minDx) / maxDx < 0.05) {\n            options.noiseLevel = getNoiseLevel(y);\n        } else {\n            options.noiseLevel = 0;\n        }\n    }\n    const yCorrection = {m: 1, b: options.noiseLevel};\n    if (!options.maxCriteria) {\n        yCorrection.m = -1;\n        yCorrection.b *= -1;\n    }\n\n    for (let i = 0; i < y.length; i++) {\n        y[i] = yCorrection.m * y[i] - yCorrection.b;\n    }\n\n    for (let i = 0; i < y.length; i++) {\n        if (y[i] < 0) {\n            y[i] = 0;\n        }\n    }\n    // If the max difference between delta x is less than 5%, then, we can assume it to be equally spaced variable\n    let Y = y;\n    let dY, ddY;\n    if ((maxDx - minDx) / maxDx < 0.05) {\n        if (options.smoothY)\n            Y = SG(y, x[1] - x[0], {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 0});\n        dY = SG(y, x[1] - x[0], {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 1});\n        ddY = SG(y, x[1] - x[0], {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 2});\n    } else {\n        if (options.smoothY)\n            Y = SG(y, x, {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 0});\n        dY = SG(y, x, {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 1});\n        ddY = SG(y, x, {windowSize: sgOptions.windowSize, polynomial: sgOptions.polynomial, derivative: 2});\n    }\n\n    const X = x;\n    const dx = x[1] - x[0];\n    var maxDdy = 0;\n    var maxY = 0;\n    for (let i = 0; i < Y.length; i++) {\n        if (Math.abs(ddY[i]) > maxDdy) {\n            maxDdy = Math.abs(ddY[i]);\n        }\n        if (Math.abs(Y[i]) > maxY) {\n            maxY = Math.abs(Y[i]);\n        }\n    }\n\n    var lastMax = null;\n    var lastMin = null;\n    var minddY = new Array(Y.length - 2);\n    var intervalL = new Array(Y.length);\n    var intervalR = new Array(Y.length);\n    var broadMask = new Array(Y.length - 2);\n    var minddYLen = 0;\n    var intervalLLen = 0;\n    var intervalRLen = 0;\n    var broadMaskLen = 0;\n    // By the intermediate value theorem We cannot find 2 consecutive maximum or minimum\n    for (let i = 1; i < Y.length - 1; ++i) {\n\n        // filter based on derivativeThreshold\n        if (Math.abs(dY[i]) > options.derivativeThreshold) {\n\n            // Minimum in first derivative\n            if ((dY[i] < dY[i - 1]) && (dY[i] <= dY[i + 1]) ||\n                (dY[i] <= dY[i - 1]) && (dY[i] < dY[i + 1])) {\n                lastMin = {\n                    x: X[i],\n                    index: i\n                };\n                if (dx > 0 && lastMax !== null) {\n                    intervalL[intervalLLen++] = lastMax;\n                    intervalR[intervalRLen++] = lastMin;\n                }\n            }\n\n            // Maximum in first derivative\n            if ((dY[i] >= dY[i - 1]) && (dY[i] > dY[i + 1]) ||\n                (dY[i] > dY[i - 1]) && (dY[i] >= dY[i + 1])) {\n                lastMax = {\n                    x: X[i],\n                    index: i\n                };\n                if (dx < 0 && lastMin !== null) {\n                    intervalL[intervalLLen++] = lastMax;\n                    intervalR[intervalRLen++] = lastMin;\n                }\n            }\n        }\n\n        // Minimum in second derivative\n        if ((ddY[i] < ddY[i - 1]) && (ddY[i] < ddY[i + 1])) {\n            // TODO should we change this to have 3 arrays ? Huge overhead creating arrays\n            minddY[minddYLen++] = i; //( [X[i], Y[i], i] );\n            broadMask[broadMaskLen++] = Math.abs(ddY[i]) <= options.broadRatio * maxDdy;\n        }\n    }\n    minddY.length = minddYLen;\n    intervalL.length = intervalLLen;\n    intervalR.length = intervalRLen;\n    broadMask.length = broadMaskLen;\n\n    let signals = new Array(minddY.length);\n    let signalsLen = 0;\n    let lastK = -1;\n    let possible, frequency, distanceJ, minDistance, gettingCloser;\n    for (let j = 0; j < minddY.length; ++j) {\n        frequency = X[minddY[j]];\n        possible = -1;\n        let k = lastK + 1;\n        minDistance = Number.MAX_VALUE;\n        distanceJ = 0;\n        gettingCloser = true;\n        while (possible === -1 && (k < intervalL.length) && gettingCloser) {\n            distanceJ = Math.abs(frequency - (intervalL[k].x + intervalR[k].x) / 2);\n\n            //Still getting closer?\n            if (distanceJ < minDistance) {\n                minDistance = distanceJ;\n            } else {\n                gettingCloser = false;\n            }\n            if (distanceJ < Math.abs(intervalL[k].x - intervalR[k].x) / 2) {\n                possible = k;\n                lastK = k;\n            }\n            ++k;\n        }\n\n        if (possible !== -1) {\n            if (Math.abs(Y[minddY[j]]) > options.minMaxRatio * maxY) {\n                signals[signalsLen++] = {\n                    index: minddY[j],\n                    x: frequency,\n                    y: (Y[minddY[j]] + yCorrection.b) / yCorrection.m,\n                    width: Math.abs(intervalR[possible].x - intervalL[possible].x), //widthCorrection\n                    soft: broadMask[j]\n                };\n                if (options.boundaries) {\n                    signals[signalsLen - 1].left = intervalL[possible];\n                    signals[signalsLen - 1].right = intervalR[possible];\n                }\n                if (options.heightFactor) {\n                    let yLeft = Y[intervalL[possible].index];\n                    let yRight = Y[intervalR[possible].index];\n                    signals[signalsLen - 1].height = options.heightFactor * (signals[signalsLen - 1].y - ((yLeft + yRight) / 2));\n                }\n            }\n        }\n    }\n    signals.length = signalsLen;\n\n    if (options.realTopDetection)\n        realTopDetection(signals, X, Y);\n\n    //Correct the values to fit the original spectra data\n    for (let j = 0; j < signals.length; j++) {\n        signals[j].base = options.noiseLevel;\n    }\n\n    signals.sort(function (a, b) {\n        return a.x - b.x;\n    });\n\n    return signals;\n\n}\n\nfunction getNoiseLevel(y) {\n    var mean = 0, stddev = 0;\n    var length = y.length;\n    for (let i = 0; i < length; ++i) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (let i = 0; i < length; ++i)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort();\n    if (length % 2 === 1) {\n        stddev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stddev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return stddev;\n}\n\nfunction realTopDetection(peakList, x, y) {\n    var alpha, beta, gamma, p, currentPoint;\n    for (var j = 0; j < peakList.length; j++) {\n        currentPoint = peakList[j].i;//peakList[j][2];\n        //The detected peak could be moved 1 or 2 unit to left or right.\n        if (y[currentPoint - 1] >= y[currentPoint - 2]\n            && y[currentPoint - 1] >= y[currentPoint]) {\n            currentPoint--;\n        } else {\n            if (y[currentPoint + 1] >= y[currentPoint]\n                && y[currentPoint + 1] >= y[currentPoint + 2]) {\n                currentPoint++;\n            } else {\n                if (y[currentPoint - 2] >= y[currentPoint - 3]\n                    && y[currentPoint - 2] >= y[currentPoint - 1]) {\n                    currentPoint -= 2;\n                } else {\n                    if (y[currentPoint + 2] >= y[currentPoint + 1]\n                        && y[currentPoint + 2] >= y[currentPoint + 3]) {\n                        currentPoint += 2;\n                    }\n                }\n            }\n        }\n        if (y[currentPoint - 1] > 0 && y[currentPoint + 1] > 0\n            && y[currentPoint] >= y[currentPoint - 1]\n            && y[currentPoint] >= y[currentPoint + 1]) {\n            alpha = 20 * Math.log10(y[currentPoint - 1]);\n            beta = 20 * Math.log10(y[currentPoint]);\n            gamma = 20 * Math.log10(y[currentPoint + 1]);\n            p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);\n            //console.log(\"p: \"+p);\n            //console.log(x[currentPoint]+\" \"+tmp+\" \"+currentPoint);\n            peakList[j].x = x[currentPoint] + (x[currentPoint] - x[currentPoint - 1]) * p;\n            peakList[j].y = y[currentPoint] - 0.25 * (y[currentPoint - 1] - y[currentPoint + 1]) * p;\n        }\n    }\n}\n\nmodule.exports = gsd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/gsd.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extend/index.js\n// module id = 16\n// module chunks = 0","//Code translate from Pascal source in http://pubs.acs.org/doi/pdf/10.1021/ac00205a007\nvar extend = require('extend');\nvar stat = require('ml-stat');\n\nvar defaultOptions = {\n    windowSize: 9,\n    derivative: 0,\n    polynomial: 3,\n};\n\n\nfunction SavitzkyGolay(data, h, options) {\n    options = extend({}, defaultOptions, options);\n\n    if ((options.windowSize % 2 === 0) || (options.windowSize < 5) || !(Number.isInteger(options.windowSize)))\n            throw new RangeError('Invalid window size (should be odd and at least 5 integer number)')\n\n\n    if (options.windowSize>data.length)\n        throw new RangeError('Window size is higher than the data length '+options.windowSize+\">\"+data.length);\n    if ((options.derivative < 0) || !(Number.isInteger(options.derivative)))\n        throw new RangeError('Derivative should be a positive integer');\n    if ((options.polynomial < 1) || !(Number.isInteger(options.polynomial)))\n        throw new RangeError('Polynomial should be a positive integer');\n    if (options.polynomial >= 6)\n        console.warn('You should not use polynomial grade higher than 5 if you are' +\n            ' not sure that your data arises from such a model. Possible polynomial oscillation problems');\n\n    var windowSize = options.windowSize;\n\n    var half = Math.floor(windowSize/2);\n    var np = data.length;\n    var ans = new Array(np);\n    var weights = fullWeights(windowSize,options.polynomial,options.derivative);\n    var hs = 0;\n    var constantH = true;\n    if( Object.prototype.toString.call( h ) === '[object Array]' ) {\n        constantH = false;\n    }\n    else{\n        hs = Math.pow(h, options.derivative);\n    }\n    //console.log(\"Constant h: \"+constantH);\n    //For the borders\n    for(var i=0;i<half;i++){\n        var wg1=weights[half-i-1];\n        var wg2=weights[half+i+1];\n        var d1 = 0,d2=0;\n        for (var l = 0; l < windowSize; l++){\n            d1 += wg1[l] * data[l];\n            d2 += wg2[l] * data[np-windowSize+l-1];\n        }\n        if(constantH){\n            ans[half-i-1] = d1/hs;\n            ans[np-half+i] = d2/hs;\n        }\n        else{\n            hs = getHs(h,half-i-1,half, options.derivative);\n            ans[half-i-1] = d1/hs;\n            hs = getHs(h,np-half+i,half, options.derivative);\n            ans[np-half+i] = d2/hs;\n        }\n    }\n    //For the internal points\n    var wg = weights[half];\n    for(var i=windowSize;i<np+1;i++){\n        var d = 0;\n        for (var l = 0; l < windowSize; l++)\n            d += wg[l] * data[l+i-windowSize];\n        if(!constantH)\n            hs = getHs(h,i-half-1,half, options.derivative);\n        ans[i-half-1] = d/hs;\n    }\n    return ans;\n}\n\nfunction getHs(h,center,half,derivative){\n    var hs = 0;\n    var count = 0;\n    for(var i=center-half;i<center+half;i++){\n        if(i>=0 && i < h.length-1){\n            hs+= (h[i+1]-h[i]);\n            count++;\n        }\n    }\n    return Math.pow(hs/count,derivative);\n}\n\nfunction GramPoly(i,m,k,s){\n    var Grampoly = 0;\n    if(k>0){\n        Grampoly = (4*k-2)/(k*(2*m-k+1))*(i*GramPoly(i,m,k-1,s) +\n            s*GramPoly(i,m,k-1,s-1)) - ((k-1)*(2*m+k))/(k*(2*m-k+1))*GramPoly(i,m,k-2,s);\n    }\n    else{\n        if(k==0&&s==0){\n            Grampoly=1;\n        }\n        else{\n            Grampoly=0;\n        }\n    }\n    //console.log(Grampoly);\n    return Grampoly;\n}\n\nfunction GenFact(a,b){\n    var gf=1;\n    if(a>=b){\n        for(var j=a-b+1;j<=a;j++){\n            gf*=j;\n        }\n    }\n    return gf;\n}\n\nfunction Weight(i,t,m,n,s){\n    var sum=0;\n    for(var k=0;k<=n;k++){\n        //console.log(k);\n        sum+=(2*k+1)*(GenFact(2*m,k)/GenFact(2*m+k+1,k+1))*GramPoly(i,m,k,0)*GramPoly(t,m,k,s)\n    }\n    return sum;\n}\n\n/**\n *\n * @param m  Number of points\n * @param n  Polynomial grade\n * @param s  Derivative\n */\nfunction fullWeights(m,n,s){\n    var weights = new Array(m);\n    var np = Math.floor(m/2);\n    for(var t=-np;t<=np;t++){\n        weights[t+np] = new Array(m);\n        for(var j=-np;j<=np;j++){\n            weights[t+np][j+np]=Weight(j,t,np,n,s);\n        }\n    }\n    return weights;\n}\n\n/*function entropy(data,h,options){\n    var trend = SavitzkyGolay(data,h,trendOptions);\n    var copy = new Array(data.length);\n    var sum = 0;\n    var max = 0;\n    for(var i=0;i<data.length;i++){\n        copy[i] = data[i]-trend[i];\n    }\n\n    sum/=data.length;\n    console.log(sum+\" \"+max);\n    console.log(stat.array.standardDeviation(copy));\n    console.log(Math.abs(stat.array.mean(copy))/stat.array.standardDeviation(copy));\n    return sum;\n\n}\n\n\n\nfunction guessWindowSize(data, h){\n    console.log(\"entropy \"+entropy(data,h,trendOptions));\n    return 5;\n}\n*/\nmodule.exports = SavitzkyGolay;\n \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-savitzky-golay-generalized/src/index.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-savitzky-golay-generalized/~/ml-stat/index.js\n// module id = 18\n// module chunks = 0","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = Infinity;\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw \"Vectors do not have the same dimensions\";\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    }\n    else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    }\n    else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof(eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = values.slice();\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-savitzky-golay-generalized/~/ml-stat/array.js\n// module id = 19\n// module chunks = 0","'use strict';\nvar arrayStat = require('./array');\n\n// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\nfunction entropy(matrix, eps) {\n    if (typeof(eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n}\n\nfunction mean(matrix, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n}\n\nfunction standardDeviation(matrix, means, unbiased) {\n    var vari = variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n}\n\nfunction variance(matrix, means, unbiased) {\n    if (typeof(unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n}\n\nfunction median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort();\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n}\n\nfunction mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n}\n\nfunction skewness(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n}\n\nfunction kurtosis(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n}\n\nfunction standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n}\n\nfunction covariance(matrix, dimension) {\n    return scatter(matrix, undefined, dimension);\n}\n\nfunction scatter(matrix, divisor, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof(divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = mean(matrix, dimension),\n        rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nfunction correlation(matrix) {\n    var means = mean(matrix),\n        standardDeviations = standardDeviation(matrix, true, means),\n        scores = zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n}\n\nfunction zScores(matrix, means, standardDeviations) {\n    means = means || mean(matrix);\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n    return standardize(center(matrix, means, false), standardDeviations, true);\n}\n\nfunction center(matrix, means, inPlace) {\n    means = means || mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n}\n\nfunction standardize(matrix, standardDeviations, inPlace) {\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction weightedVariance(matrix, weights) {\n    var means = mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n}\n\nfunction weightedMean(matrix, weights, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n}\n\nfunction weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return weightedScatter(matrix, weights, means, factor, dimension);\n}\n\nfunction weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    if (typeof(factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nmodule.exports = {\n    entropy: entropy,\n    mean: mean,\n    standardDeviation: standardDeviation,\n    variance: variance,\n    median: median,\n    mode: mode,\n    skewness: skewness,\n    kurtosis: kurtosis,\n    standardError: standardError,\n    covariance: covariance,\n    scatter: scatter,\n    correlation: correlation,\n    zScores: zScores,\n    center: center,\n    standardize: standardize,\n    weightedVariance: weightedVariance,\n    weightedMean: weightedMean,\n    weightedCovariance: weightedCovariance,\n    weightedScatter: weightedScatter\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-savitzky-golay-generalized/~/ml-stat/matrix.js\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}