'use strict';

module.exports = function (OCL) {
    return function getFunctionCodes() {
        var molecule = this.getCompactCopy();
        var atoms = molecule.getAtomsInfo();
        for (var i = 0; i < molecule.getAllAtoms(); i++) {
            var atom = atoms[i];
            atom.i = i;
            atom.mapNo = molecule.getAtomMapNo(i);
            atom.links = []; // we will store connected atoms of broken bonds
        }

        var bonds = [];
        for (var _i = 0; _i < molecule.getAllBonds(); _i++) {
            var bond = {};
            bonds.push(bond);
            bond.i = _i;
            bond.order = molecule.getBondOrder(_i);
            bond.atom1 = molecule.getBondAtom(0, _i);
            bond.atom2 = molecule.getBondAtom(1, _i);
            bond.type = molecule.getBondType(_i);
            bond.isAromatic = molecule.isAromaticBond(_i);

            if (!bond.isAromatic && molecule.getBondTypeSimple(_i) === 1 && molecule.getAtomicNo(bond.atom1) === 6 && molecule.getAtomicNo(bond.atom2) === 6 && (atoms[bond.atom1].extra.cnoHybridation === 3 || atoms[bond.atom2].extra.cnoHybridation === 3)) {

                bond.selected = true;
                atoms[bond.atom1].links.push(bond.atom2);
                atoms[bond.atom2].links.push(bond.atom1);
            }
        }

        var brokenMolecule = molecule.getCompactCopy();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = bonds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _bond = _step.value;

                if (_bond.selected) {
                    brokenMolecule.markBondForDeletion(_bond.i);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        brokenMolecule.deleteMarkedAtomsAndBonds();
        var fragmentMap = [];
        var nbFragments = brokenMolecule.getFragmentNumbers(fragmentMap);

        var results = {};

        var _loop = function _loop(_i2) {
            result = {};

            result.atomMap = [];
            includeAtom = fragmentMap.map(function (id) {
                return id === _i2;
            });
            fragment = new OCL.Molecule();
            atomMap = [];

            brokenMolecule.copyMoleculeByAtoms(fragment, includeAtom, false, atomMap);
            parent = fragment.getCompactCopy();

            parent.setFragment(true);
            // we will remove the hydrogens of the broken carbon
            for (var j = 0; j < atomMap.length; j++) {
                if (atomMap[j] > -1) {
                    //                var numberDeletedHydrogens = 0;
                    if (atoms[j].links.length > 0) {
                        for (var k = 0; k < atoms[j].links.length; k++) {
                            if (parent.getAtomicNo(atoms[j].links[k]) === 1) {
                                //                           numberDeletedHydrogens++;
                                fragment.deleteAtom(atoms[j].links[k]);
                            }
                        }
                    }
                    fragment.ensureHelperArrays(OCL.Molecule.cHelperBitNeighbours);
                    // we will allow any substitution on sp3 hydrogens
                    // that is at an extremety (only one connection)

                    if (atoms[j].atomicNo === 6 && fragment.getConnAtoms(atomMap[j]) > 1) {
                        if (atoms[j].allHydrogens !== 0) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot0Hydrogen, true);
                        if (atoms[j].allHydrogens !== 1) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot1Hydrogen, true);
                        if (atoms[j].allHydrogens !== 2) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot2Hydrogen, true);
                        if (atoms[j].allHydrogens !== 3) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot3Hydrogen, true);
                    }
                    if (atoms[j].atomicNo !== 6) {
                        parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNoMoreNeighbours, true);
                    }
                }
            }

            result.parent = parent.getIDCode();
            fragment.setFragment(false); // required for small molecules like methanol

            // we will add some R groups at the level of the broken bonds
            for (var _j = 0; _j < atomMap.length; _j++) {
                if (atomMap[_j] > -1) {
                    result.atomMap.push(_j);
                    if (atoms[_j].links.length > 0) {
                        for (var _k = 0; _k < atoms[_j].links.length; _k++) {
                            rGroup = fragment.addAtom(154);
                            x = molecule.getAtomX(atoms[_j].links[_k]);
                            y = molecule.getAtomY(atoms[_j].links[_k]);

                            fragment.setAtomX(rGroup, x);
                            fragment.setAtomY(rGroup, y);
                            fragment.addBond(atomMap[_j], rGroup, 1);
                        }
                    }
                }
            }
            result.idCode = fragment.getIDCode();

            if (results[result.idCode]) {
                results[result.idCode].atomMap = results[result.idCode].atomMap.concat(result.atomMap);
            } else {
                results[result.idCode] = {
                    atomMap: result.atomMap,
                    idCode: result.idCode
                };
            }

            if (results[result.parent]) {
                results[result.parent].atomMap = results[result.parent].atomMap.concat(result.atomMap);
            } else {
                results[result.parent] = {
                    atomMap: result.atomMap,
                    idCode: result.parent
                };
            }
        };

        for (var _i2 = 0; _i2 < nbFragments; _i2++) {
            var result;
            var includeAtom;
            var fragment;
            var atomMap;
            var parent;
            var rGroup;
            var x;
            var y;

            _loop(_i2);
        }

        // fragments should be unique
        var fragments = [];
        Object.keys(results).forEach(function (key) {
            fragments.push(results[key]);
        });
        return fragments;
    };
};